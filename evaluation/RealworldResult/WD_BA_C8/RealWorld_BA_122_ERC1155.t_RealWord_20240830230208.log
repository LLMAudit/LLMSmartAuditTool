[2024-30-08 23:02:09 INFO] **[Preprocessing]**

**ChatDev Starts** (20240830230208)

**Timestamp**: 20240830230208

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}


**project_name**: RealWorld_BA_122_ERC1155.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_122_ERC1155.t_RealWord_20240830230208.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-30-08 23:02:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\n\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\n\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:09 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-30-08 23:02:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28904
completion_tokens: 1
total_tokens: 28905
cost: $-1.000000


[2024-30-08 23:02:13 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Let's

[2024-30-08 23:02:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\ncontract NonERC1155Recipient {}\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n    function setUp() public {\n        token = new MockERC1155();\n    }\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        token.mint(address(to), 1337, 1, "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 1);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n        token.batchMint(address(to), ids, amounts, "testing 123");\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.burn(address(0xBEEF), 1337, 70);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n        token.mint(from, 1337, 100, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        address from = address(0xABCD);\n        token.mint(from, 1337, 100, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n        token.mint(from, 1337, 70, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        token.balanceOfBatch(tos, ids);\n    }\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        token.mint(to, id, amount, mintData);\n        assertEq(token.balanceOf(to, id), amount);\n    }\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        token.mint(address(to), id, amount, mintData);\n        assertEq(token.balanceOf(address(to), id), amount);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[to][id] += mintAmount;\n        }\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        burnAmount = bound(burnAmount, 0, mintAmount);\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        address from = address(0xABCD);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        address from = address(0xABCD);\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            token.mint(to, id, mintAmount, mintData);\n            userMintAmounts[to][id] += mintAmount;\n        }\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        if (minLength == 0) revert();\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        if (ids.length == transferAmounts.length) revert();\n        token.batchMint(from, ids, mintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n        if (minLength == 0) revert();\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n        token.batchMint(to, ids, mintAmounts, mintData);\n        token.batchBurn(to, ids, burnAmounts);\n    }\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n        token.balanceOfBatch(tos, ids);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\ncontract NonERC1155Recipient {}\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n    function setUp() public {\n        token = new MockERC1155();\n    }\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        token.mint(address(to), 1337, 1, "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 1);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n        token.batchMint(address(to), ids, amounts, "testing 123");\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.burn(address(0xBEEF), 1337, 70);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n        token.mint(from, 1337, 100, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        address from = address(0xABCD);\n        token.mint(from, 1337, 100, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n        token.mint(from, 1337, 70, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        token.batchMint(from, ids, mintAmounts, "");\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        token.balanceOfBatch(tos, ids);\n    }\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        token.mint(to, id, amount, mintData);\n        assertEq(token.balanceOf(to, id), amount);\n    }\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        token.mint(address(to), id, amount, mintData);\n        assertEq(token.balanceOf(address(to), id), amount);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[to][id] += mintAmount;\n        }\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        burnAmount = bound(burnAmount, 0, mintAmount);\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        address from = address(0xABCD);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n        address from = address(0xABCD);\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        ERC1155Recipient to = new ERC1155Recipient();\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            token.mint(to, id, mintAmount, mintData);\n            userMintAmounts[to][id] += mintAmount;\n        }\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n        token.mint(from, id, mintAmount, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        if (minLength == 0) revert();\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n            userMintAmounts[from][id] += mintAmount;\n        }\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n        if (ids.length == transferAmounts.length) revert();\n        token.batchMint(from, ids, mintAmounts, mintData);\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n        uint256 minLength = min2(ids.length, amounts.length);\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n        if (minLength == 0) revert();\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n        token.batchMint(to, ids, mintAmounts, mintData);\n        token.batchBurn(to, ids, burnAmounts);\n    }\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n        token.balanceOfBatch(tos, ids);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:14 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;
import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";
import {MockERC1155} from "./utils/mocks/MockERC1155.sol";
import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";
contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;
    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;
        return ERC1155TokenReceiver.onERC1155Received.selector;
    }
    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;
    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }
    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }
    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;
        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}
contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}
contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}
contract NonERC1155Recipient {}
contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;
    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;
    function setUp() public {
        token = new MockERC1155();
    }
    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }
    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        token.mint(address(to), 1337, 1, "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 1);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }
    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;
        token.batchMint(address(0xBEEF), ids, amounts, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }
    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;
        token.batchMint(address(to), ids, amounts, "testing 123");
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }
    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");
        token.burn(address(0xBEEF), 1337, 70);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }
    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }
    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);
        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }
    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);
        token.mint(from, 1337, 100, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }
    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        address from = address(0xABCD);
        token.mint(from, 1337, 100, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");
        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }
    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }
    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }
    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);
        ERC1155Recipient to = new ERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");
        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);
        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);
        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);
        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);
        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }
    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");
        uint256[] memory balances = token.balanceOfBatch(tos, ids);
        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }
    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }
    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }
    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }
    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }
    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }
    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);
        token.mint(from, 1337, 70, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }
    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }
    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }
    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }
    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(0), ids, mintAmounts, "");
    }
    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        token.batchMint(address(0xBEEF), ids, amounts, "");
    }
    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;
        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }
    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }
    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);
        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        token.balanceOfBatch(tos, ids);
    }
    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        token.mint(to, id, amount, mintData);
        assertEq(token.balanceOf(to, id), amount);
    }
    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        token.mint(address(to), id, amount, mintData);
        assertEq(token.balanceOf(address(to), id), amount);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }
    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[to][id] += mintAmount;
        }
        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }
    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }
    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        burnAmount = bound(burnAmount, 0, mintAmount);
        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }
    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);
            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }
        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);
        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }
    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);
        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }
    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        transferAmount = bound(transferAmount, 0, mintAmount);
        address from = address(0xABCD);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, to, id, transferAmount, transferData);
        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }
    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        address from = address(0xABCD);
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);
        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }
    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }
    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }
    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        ERC1155Recipient to = new ERC1155Recipient();
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];
            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }
    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);
        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            normalizedTos[i] = to;
            normalizedIds[i] = id;
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            token.mint(to, id, mintAmount, mintData);
            userMintAmounts[to][id] += mintAmount;
        }
        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);
        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }
    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }
    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);
        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }
    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }
    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }
    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }
    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        if (minLength == 0) revert();
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }
    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }
    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        if (ids.length == transferAmounts.length) revert();
        token.batchMint(from, ids, mintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }
    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(0)][id] += mintAmount;
        }
        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();
        token.batchMint(address(to), ids, amounts, mintData);
    }
    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);
        if (minLength == 0) revert();
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);
            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }
        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);
        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }
    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();
        token.batchMint(to, ids, mintAmounts, mintData);
        token.batchBurn(to, ids, burnAmounts);
    }
    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();
        token.balanceOfBatch(tos, ids);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;
import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";
import {MockERC1155} from "./utils/mocks/MockERC1155.sol";
import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";
contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;
    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;
        return ERC1155TokenReceiver.onERC1155Received.selector;
    }
    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;
    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }
    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }
    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;
        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}
contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}
contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}
contract NonERC1155Recipient {}
contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;
    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;
    function setUp() public {
        token = new MockERC1155();
    }
    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }
    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        token.mint(address(to), 1337, 1, "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 1);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }
    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;
        token.batchMint(address(0xBEEF), ids, amounts, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }
    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;
        token.batchMint(address(to), ids, amounts, "testing 123");
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }
    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");
        token.burn(address(0xBEEF), 1337, 70);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }
    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }
    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);
        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }
    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);
        token.mint(from, 1337, 100, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }
    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();
        address from = address(0xABCD);
        token.mint(from, 1337, 100, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");
        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }
    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");
        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }
    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }
    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);
        ERC1155Recipient to = new ERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");
        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);
        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);
        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);
        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);
        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }
    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");
        uint256[] memory balances = token.balanceOfBatch(tos, ids);
        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }
    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }
    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }
    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }
    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }
    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }
    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);
        token.mint(from, 1337, 70, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }
    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }
    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }
    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }
    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }
    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        token.batchMint(from, ids, mintAmounts, "");
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }
    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(0), ids, mintAmounts, "");
    }
    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        token.batchMint(address(to), ids, mintAmounts, "");
    }
    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        token.batchMint(address(0xBEEF), ids, amounts, "");
    }
    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;
        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }
    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;
        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;
        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        token.batchMint(address(0xBEEF), ids, mintAmounts, "");
        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }
    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);
        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        token.balanceOfBatch(tos, ids);
    }
    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        token.mint(to, id, amount, mintData);
        assertEq(token.balanceOf(to, id), amount);
    }
    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        token.mint(address(to), id, amount, mintData);
        assertEq(token.balanceOf(address(to), id), amount);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }
    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[to][id] += mintAmount;
        }
        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }
    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }
    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        burnAmount = bound(burnAmount, 0, mintAmount);
        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }
    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);
            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }
        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);
        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }
    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);
        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }
    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        transferAmount = bound(transferAmount, 0, mintAmount);
        address from = address(0xABCD);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, to, id, transferAmount, transferData);
        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }
    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();
        address from = address(0xABCD);
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);
        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);
        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }
    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }
    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);
        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }
    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        ERC1155Recipient to = new ERC1155Recipient();
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);
        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);
        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];
            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }
    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);
        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            normalizedTos[i] = to;
            normalizedIds[i] = id;
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            token.mint(to, id, mintAmount, mintData);
            userMintAmounts[to][id] += mintAmount;
        }
        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);
        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }
    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }
    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }
    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);
        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }
    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);
        token.mint(from, id, mintAmount, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }
    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }
    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }
    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);
        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }
    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        if (minLength == 0) revert();
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }
    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }
    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];
            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;
            userMintAmounts[from][id] += mintAmount;
        }
        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }
    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);
        if (ids.length == transferAmounts.length) revert();
        token.batchMint(from, ids, mintAmounts, mintData);
        hevm.prank(from);
        token.setApprovalForAll(address(this), true);
        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }
    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(0)][id] += mintAmount;
        }
        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();
        uint256 minLength = min2(ids.length, amounts.length);
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];
            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);
            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;
            userMintAmounts[address(to)][id] += mintAmount;
        }
        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }
    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();
        token.batchMint(address(to), ids, amounts, mintData);
    }
    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);
        if (minLength == 0) revert();
        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);
        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];
            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);
            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }
        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);
        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }
    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();
        token.batchMint(to, ids, mintAmounts, mintData);
        token.batchBurn(to, ids, burnAmounts);
    }
    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();
        token.balanceOfBatch(tos, ids);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-30-08 23:02:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 43411
completion_tokens: 1
total_tokens: 43412
cost: $-1.000000


[2024-30-08 23:02:23 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Security

[2024-30-08 23:02:23 INFO] **[Seminar Conclusion]**:

 Security

[2024-30-08 23:02:23 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-30-08 23:02:23 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-30-08 23:02:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\n\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\n\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:23 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-30-08 23:02:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28895
completion_tokens: 1
total_tokens: 28896
cost: $-1.000000


[2024-30-08 23:02:27 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

###

[2024-30-08 23:02:27 INFO] **[Seminar Conclusion]**:

 ###

[2024-30-08 23:02:27 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-30-08 23:02:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:27 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-30-08 23:02:39 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:39 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14507
completion_tokens: 771
total_tokens: 15278
cost: $-1.000000


[2024-30-08 23:02:39 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Based on the provided Solidity smart contract code, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, which could allow malicious contracts to exploit functions that change state after external calls.

2. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., batch operations) may run into gas limit issues if the input arrays are too large. This could lead to failed transactions.

3. **Insufficient Input Validation**:
   - There is a lack of thorough input validation in functions that handle transfers and mints. For instance, the contract does not check if the `amount` is greater than zero before proceeding with minting or transferring tokens.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, its essential to ensure that all arithmetic operations are safe, especially when dealing with user inputs.

5. **Improper Error Handling**:
   - The contract relies on revert messages that may not provide sufficient context for debugging. Custom error messages could improve clarity.

6. **Lack of Access Control**:
   - Functions that modify state or perform sensitive operations do not have adequate access control mechanisms, which could allow unauthorized users to execute them.

7. **Use of `address(0)`**:
   - The contract allows minting to the zero address, which is a common anti-pattern in ERC standards. This could lead to loss of tokens.

8. **Handling of ERC1155 Receiver Logic**:
   - The contract does not properly handle cases where the recipient is not a valid ERC1155 receiver, which could lead to tokens being sent to contracts that cannot handle them.

9. **Batch Operations**:
   - The batch minting and transferring functions do not check for mismatched array lengths, which could lead to unexpected behavior or failures.

10. **Fallback Function**:
    - The contract does not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds.

### Comprehensive Analysis Report:

The provided smart contract code demonstrates a foundational understanding of the ERC1155 standard, but it also reveals several critical security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and improper error handling are particularly concerning, as they could lead to significant financial losses.

Moreover, the absence of access control mechanisms raises the risk of unauthorized access to sensitive functions, while the potential for integer overflow/underflow, despite Solidity's built-in protections, necessitates careful scrutiny of all arithmetic operations.

The handling of batch operations and the possibility of minting to the zero address are additional areas of concern that could lead to unintended consequences. Overall, while the contract is functional, it requires significant improvements in security practices to ensure the safety and integrity of user funds.

### Recommendations:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect against reentrancy attacks.
2. **Enhance Input Validation**: Ensure that all inputs are validated, particularly for minting and transferring functions.
3. **Implement Access Control**: Use modifiers to restrict access to sensitive functions.
4. **Check for Zero Address**: Prevent minting or transferring tokens to the zero address.
5. **Improve Error Handling**: Use custom error messages for better debugging.
6. **Add Fallback Function**: Implement a fallback function to handle unexpected Ether transfers.
7. **Thorough Testing**: Conduct extensive testing, including unit tests and fuzz testing, to identify edge cases and potential vulnerabilities.

By addressing these vulnerabilities, the contract can be made significantly more secure and robust against potential attacks.

[2024-30-08 23:02:39 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code, the following security vulnerabilities and issues have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, which could allow malicious contracts to exploit functions that change state after external calls.

2. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., batch operations) may run into gas limit issues if the input arrays are too large. This could lead to failed transactions.

3. **Insufficient Input Validation**:
   - There is a lack of thorough input validation in functions that handle transfers and mints. For instance, the contract does not check if the `amount` is greater than zero before proceeding with minting or transferring tokens.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, its essential to ensure that all arithmetic operations are safe, especially when dealing with user inputs.

5. **Improper Error Handling**:
   - The contract relies on revert messages that may not provide sufficient context for debugging. Custom error messages could improve clarity.

6. **Lack of Access Control**:
   - Functions that modify state or perform sensitive operations do not have adequate access control mechanisms, which could allow unauthorized users to execute them.

7. **Use of `address(0)`**:
   - The contract allows minting to the zero address, which is a common anti-pattern in ERC standards. This could lead to loss of tokens.

8. **Handling of ERC1155 Receiver Logic**:
   - The contract does not properly handle cases where the recipient is not a valid ERC1155 receiver, which could lead to tokens being sent to contracts that cannot handle them.

9. **Batch Operations**:
   - The batch minting and transferring functions do not check for mismatched array lengths, which could lead to unexpected behavior or failures.

10. **Fallback Function**:
    - The contract does not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds.

### Comprehensive Analysis Report:

The provided smart contract code demonstrates a foundational understanding of the ERC1155 standard, but it also reveals several critical security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and improper error handling are particularly concerning, as they could lead to significant financial losses.

Moreover, the absence of access control mechanisms raises the risk of unauthorized access to sensitive functions, while the potential for integer overflow/underflow, despite Solidity's built-in protections, necessitates careful scrutiny of all arithmetic operations.

The handling of batch operations and the possibility of minting to the zero address are additional areas of concern that could lead to unintended consequences. Overall, while the contract is functional, it requires significant improvements in security practices to ensure the safety and integrity of user funds.

### Recommendations:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect against reentrancy attacks.
2. **Enhance Input Validation**: Ensure that all inputs are validated, particularly for minting and transferring functions.
3. **Implement Access Control**: Use modifiers to restrict access to sensitive functions.
4. **Check for Zero Address**: Prevent minting or transferring tokens to the zero address.
5. **Improve Error Handling**: Use custom error messages for better debugging.
6. **Add Fallback Function**: Implement a fallback function to handle unexpected Ether transfers.
7. **Thorough Testing**: Conduct extensive testing, including unit tests and fuzz testing, to identify edge cases and potential vulnerabilities.

By addressing these vulnerabilities, the contract can be made significantly more secure and robust against potential attacks.

[2024-30-08 23:02:39 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-30-08 23:02:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\n\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\n\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:39 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-30-08 23:02:44 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:44 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28895
completion_tokens: 1
total_tokens: 28896
cost: $-1.000000


[2024-30-08 23:02:44 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

###

[2024-30-08 23:02:44 INFO] **[Seminar Conclusion]**:

 ###

[2024-30-08 23:02:44 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-30-08 23:02:44 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:44 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:44 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-30-08 23:02:58 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:02:58 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14507
completion_tokens: 725
total_tokens: 15232
cost: $-1.000000


[2024-30-08 23:02:58 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Based on the provided smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contracts do not implement checks to prevent reentrancy attacks, particularly in functions that modify state variables and transfer tokens. This could allow malicious actors to exploit the contract by repeatedly calling functions before the state is updated.

2. **Incorrect Return Data Handling**:
   - The `WrongReturnDataERC1155Recipient` contract returns an incorrect selector (0xCAFEBEEF) instead of the expected selector. This could lead to unexpected behavior when tokens are transferred to this contract, potentially causing the transfer to fail without proper error handling.

3. **Insufficient Balance Checks**:
   - Functions such as `burn` and `safeTransferFrom` do not adequately check for sufficient balances before performing operations. This could allow users to attempt to burn or transfer more tokens than they own, leading to failed transactions without clear feedback.

4. **Approval Race Conditions**:
   - The `setApprovalForAll` function allows for potential race conditions where a user could approve a spender and then immediately call a transfer function, leading to unexpected behavior if not handled correctly.

5. **Minting to Zero Address**:
   - The contracts allow minting tokens to the zero address, which is a common vulnerability that can lead to loss of tokens since they cannot be retrieved once minted to this address.

6. **Non-ERC1155 Recipient Handling**:
   - The contracts do not properly handle cases where tokens are sent to non-ERC1155 compliant contracts, which could lead to tokens being locked or lost.

7. **Batch Operations with Mismatched Array Lengths**:
   - Functions that handle batch operations do not adequately check for mismatched array lengths between IDs and amounts, which could lead to unexpected behavior or failed transactions.

8. **Lack of Access Control**:
   - There is insufficient access control on critical functions, which could allow unauthorized users to execute sensitive operations.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy protection, incorrect return data handling, and insufficient balance checks are particularly concerning as they could lead to significant financial losses. Additionally, the ability to mint tokens to the zero address and the handling of non-ERC1155 recipients without proper checks could result in tokens being irretrievably lost.

To enhance the security of the contracts, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and implement reentrancy guards in functions that modify state and transfer tokens.
- **Return Data Validation**: Ensure that contracts receiving tokens return the correct selector to prevent unexpected failures.
- **Balance Checks**: Implement strict checks for sufficient balances before allowing burns or transfers.
- **Approval Management**: Consider using a more secure approach for managing approvals to prevent race conditions.
- **Zero Address Checks**: Prevent minting and transferring tokens to the zero address.
- **Recipient Validation**: Implement checks to ensure that tokens are only sent to valid ERC1155 recipients.
- **Batch Operation Validations**: Ensure that all batch operations validate array lengths before proceeding.
- **Access Control**: Introduce robust access control mechanisms to restrict sensitive operations to authorized users only.

By addressing these vulnerabilities, the overall security posture of the smart contracts can be significantly improved, reducing the risk of exploitation and ensuring a safer environment for users interacting with the contracts.

[2024-30-08 23:02:58 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contracts do not implement checks to prevent reentrancy attacks, particularly in functions that modify state variables and transfer tokens. This could allow malicious actors to exploit the contract by repeatedly calling functions before the state is updated.

2. **Incorrect Return Data Handling**:
   - The `WrongReturnDataERC1155Recipient` contract returns an incorrect selector (0xCAFEBEEF) instead of the expected selector. This could lead to unexpected behavior when tokens are transferred to this contract, potentially causing the transfer to fail without proper error handling.

3. **Insufficient Balance Checks**:
   - Functions such as `burn` and `safeTransferFrom` do not adequately check for sufficient balances before performing operations. This could allow users to attempt to burn or transfer more tokens than they own, leading to failed transactions without clear feedback.

4. **Approval Race Conditions**:
   - The `setApprovalForAll` function allows for potential race conditions where a user could approve a spender and then immediately call a transfer function, leading to unexpected behavior if not handled correctly.

5. **Minting to Zero Address**:
   - The contracts allow minting tokens to the zero address, which is a common vulnerability that can lead to loss of tokens since they cannot be retrieved once minted to this address.

6. **Non-ERC1155 Recipient Handling**:
   - The contracts do not properly handle cases where tokens are sent to non-ERC1155 compliant contracts, which could lead to tokens being locked or lost.

7. **Batch Operations with Mismatched Array Lengths**:
   - Functions that handle batch operations do not adequately check for mismatched array lengths between IDs and amounts, which could lead to unexpected behavior or failed transactions.

8. **Lack of Access Control**:
   - There is insufficient access control on critical functions, which could allow unauthorized users to execute sensitive operations.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy protection, incorrect return data handling, and insufficient balance checks are particularly concerning as they could lead to significant financial losses. Additionally, the ability to mint tokens to the zero address and the handling of non-ERC1155 recipients without proper checks could result in tokens being irretrievably lost.

To enhance the security of the contracts, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and implement reentrancy guards in functions that modify state and transfer tokens.
- **Return Data Validation**: Ensure that contracts receiving tokens return the correct selector to prevent unexpected failures.
- **Balance Checks**: Implement strict checks for sufficient balances before allowing burns or transfers.
- **Approval Management**: Consider using a more secure approach for managing approvals to prevent race conditions.
- **Zero Address Checks**: Prevent minting and transferring tokens to the zero address.
- **Recipient Validation**: Implement checks to ensure that tokens are only sent to valid ERC1155 recipients.
- **Batch Operation Validations**: Ensure that all batch operations validate array lengths before proceeding.
- **Access Control**: Introduce robust access control mechanisms to restrict sensitive operations to authorized users only.

By addressing these vulnerabilities, the overall security posture of the smart contracts can be significantly improved, reducing the risk of exploitation and ensuring a safer environment for users interacting with the contracts.

[2024-30-08 23:02:58 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-30-08 23:02:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\n\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\n\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:02:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:02:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-30-08 23:03:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:03:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 28895
completion_tokens: 1
total_tokens: 28896
cost: $-1.000000


[2024-30-08 23:03:03 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

###

[2024-30-08 23:03:03 INFO] **[Seminar Conclusion]**:

 ###

[2024-30-08 23:03:03 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-30-08 23:03:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-30-08 23:03:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:03:03 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-30-08 23:03:14 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-30-08 23:03:14 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14507
completion_tokens: 695
total_tokens: 15202
cost: $-1.000000


[2024-30-08 23:03:14 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contracts do not implement any protection against reentrancy attacks, which could allow malicious actors to exploit the contract during state changes.

2. **Gas Limit and Loops**: 
   - Functions that involve batch operations (e.g., `safeBatchTransferFrom`, `batchMint`) may run into gas limit issues if the input arrays are too large, potentially leading to failed transactions.

3. **Incorrect Return Data Handling**: 
   - The `WrongReturnDataERC1155Recipient` contract returns an incorrect selector, which could lead to unexpected behavior when interacting with ERC1155 tokens.

4. **Insufficient Balance Checks**: 
   - The contracts do not adequately check for sufficient balances before executing transfers or burns, which could lead to underflows or unexpected states.

5. **Approval Race Condition**: 
   - The `setApprovalForAll` function can be exploited if a user sets approval and then a malicious actor calls a transfer function before the user confirms the approval.

6. **Lack of Access Control**: 
   - There are no access control mechanisms in place for critical functions, which could allow unauthorized users to execute sensitive operations.

7. **Potential Denial of Service (DoS)**: 
   - If a recipient contract reverts during a transfer, it could prevent further transfers to that contract, effectively locking tokens.

8. **Unrestricted Minting**: 
   - The minting functions do not have restrictions on who can mint tokens, which could lead to token inflation if misused.

9. **Fallback Function Vulnerability**: 
   - The contracts do not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds.

### Comprehensive Analysis Report

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds, denial of service, or unintended behavior. The lack of reentrancy protection, insufficient balance checks, and incorrect return data handling are particularly concerning, as they can lead to significant issues during token transfers and minting operations.

Moreover, the absence of access control measures allows unauthorized users to execute critical functions, increasing the risk of exploitation. The potential for gas limit issues during batch operations further complicates the contract's reliability, as it may lead to failed transactions under certain conditions.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and implement reentrancy guards on critical functions.
- **Gas Limit Management**: Introduce checks to limit the size of input arrays for batch operations.
- **Return Data Validation**: Ensure that recipient contracts return the correct selector and handle unexpected return values gracefully.
- **Balance Checks**: Implement strict checks for sufficient balances before executing transfers and burns.
- **Access Control**: Introduce role-based access control to restrict critical functions to authorized users only.
- **Fallback Functions**: Implement fallback functions to handle unexpected Ether transfers appropriately.
- **Minting Restrictions**: Add restrictions to minting functions to prevent unauthorized minting and potential token inflation.

By addressing these vulnerabilities, the security and reliability of the smart contracts can be significantly enhanced, providing a safer environment for users and their assets.

[2024-30-08 23:03:14 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contracts do not implement any protection against reentrancy attacks, which could allow malicious actors to exploit the contract during state changes.

2. **Gas Limit and Loops**: 
   - Functions that involve batch operations (e.g., `safeBatchTransferFrom`, `batchMint`) may run into gas limit issues if the input arrays are too large, potentially leading to failed transactions.

3. **Incorrect Return Data Handling**: 
   - The `WrongReturnDataERC1155Recipient` contract returns an incorrect selector, which could lead to unexpected behavior when interacting with ERC1155 tokens.

4. **Insufficient Balance Checks**: 
   - The contracts do not adequately check for sufficient balances before executing transfers or burns, which could lead to underflows or unexpected states.

5. **Approval Race Condition**: 
   - The `setApprovalForAll` function can be exploited if a user sets approval and then a malicious actor calls a transfer function before the user confirms the approval.

6. **Lack of Access Control**: 
   - There are no access control mechanisms in place for critical functions, which could allow unauthorized users to execute sensitive operations.

7. **Potential Denial of Service (DoS)**: 
   - If a recipient contract reverts during a transfer, it could prevent further transfers to that contract, effectively locking tokens.

8. **Unrestricted Minting**: 
   - The minting functions do not have restrictions on who can mint tokens, which could lead to token inflation if misused.

9. **Fallback Function Vulnerability**: 
   - The contracts do not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds.

### Comprehensive Analysis Report

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds, denial of service, or unintended behavior. The lack of reentrancy protection, insufficient balance checks, and incorrect return data handling are particularly concerning, as they can lead to significant issues during token transfers and minting operations.

Moreover, the absence of access control measures allows unauthorized users to execute critical functions, increasing the risk of exploitation. The potential for gas limit issues during batch operations further complicates the contract's reliability, as it may lead to failed transactions under certain conditions.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and implement reentrancy guards on critical functions.
- **Gas Limit Management**: Introduce checks to limit the size of input arrays for batch operations.
- **Return Data Validation**: Ensure that recipient contracts return the correct selector and handle unexpected return values gracefully.
- **Balance Checks**: Implement strict checks for sufficient balances before executing transfers and burns.
- **Access Control**: Introduce role-based access control to restrict critical functions to authorized users only.
- **Fallback Functions**: Implement fallback functions to handle unexpected Ether transfers appropriately.
- **Minting Restrictions**: Add restrictions to minting functions to prevent unauthorized minting and potential token inflation.

By addressing these vulnerabilities, the security and reliability of the smart contracts can be significantly enhanced, providing a safer environment for users and their assets.

[2024-30-08 23:03:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from "./utils/DSTestPlus.sol";\nimport {DSInvariantTest} from "./utils/DSInvariantTest.sol";\n\nimport {MockERC1155} from "./utils/mocks/MockERC1155.sol";\n\nimport {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";\n\ncontract ERC1155Recipient is ERC1155TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    uint256 public amount;\n    bytes public mintData;\n\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        amount = _amount;\n        mintData = _data;\n\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    address public batchOperator;\n    address public batchFrom;\n    uint256[] internal _batchIds;\n    uint256[] internal _batchAmounts;\n    bytes public batchData;\n\n    function batchIds() external view returns (uint256[] memory) {\n        return _batchIds;\n    }\n\n    function batchAmounts() external view returns (uint256[] memory) {\n        return _batchAmounts;\n    }\n\n    function onERC1155BatchReceived(\n        address _operator,\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external override returns (bytes4) {\n        batchOperator = _operator;\n        batchFrom = _from;\n        _batchIds = _ids;\n        _batchAmounts = _amounts;\n        batchData = _data;\n\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n\ncontract RevertingERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));\n    }\n}\n\ncontract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC1155Recipient {}\n\ncontract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {\n    MockERC1155 token;\n\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts;\n    mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;\n\n    function setUp() public {\n        token = new MockERC1155();\n    }\n\n    function testMintToEOA() public {\n        token.mint(address(0xBEEF), 1337, 1, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);\n    }\n\n    function testMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), 1337, 1, "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n    }\n\n    function testBatchMintToEOA() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);\n    }\n\n    function testBatchMintToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n        amounts[4] = 500;\n\n        token.batchMint(address(to), ids, amounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), amounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 100);\n        assertEq(token.balanceOf(address(to), 1338), 200);\n        assertEq(token.balanceOf(address(to), 1339), 300);\n        assertEq(token.balanceOf(address(to), 1340), 400);\n        assertEq(token.balanceOf(address(to), 1341), 500);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337, 100, "");\n\n        token.burn(address(0xBEEF), 1337, 70);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);\n    }\n\n    function testBatchBurn() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n        burnAmounts[4] = 250;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromToERC1155Recipient() public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 100, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.mintData(), "testing 123");\n\n        assertEq(token.balanceOf(address(to), 1337), 70);\n        assertEq(token.balanceOf(from, 1337), 30);\n    }\n\n    function testSafeTransferFromSelf() public {\n        token.mint(address(this), 1337, 100, "");\n\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");\n\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);\n        assertEq(token.balanceOf(address(this), 1337), 30);\n    }\n\n    function testSafeBatchTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), ids);\n        assertUintArrayEq(to.batchAmounts(), transferAmounts);\n        assertBytesEq(to.batchData(), "testing 123");\n\n        assertEq(token.balanceOf(from, 1337), 50);\n        assertEq(token.balanceOf(address(to), 1337), 50);\n\n        assertEq(token.balanceOf(from, 1338), 100);\n        assertEq(token.balanceOf(address(to), 1338), 100);\n\n        assertEq(token.balanceOf(from, 1339), 150);\n        assertEq(token.balanceOf(address(to), 1339), 150);\n\n        assertEq(token.balanceOf(from, 1340), 200);\n        assertEq(token.balanceOf(address(to), 1340), 200);\n\n        assertEq(token.balanceOf(from, 1341), 250);\n        assertEq(token.balanceOf(address(to), 1341), 250);\n    }\n\n    function testBatchBalanceOf() public {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        token.mint(address(0xBEEF), 1337, 100, "");\n        token.mint(address(0xCAFE), 1338, 200, "");\n        token.mint(address(0xFACE), 1339, 300, "");\n        token.mint(address(0xDEAD), 1340, 400, "");\n        token.mint(address(0xFEED), 1341, 500, "");\n\n        uint256[] memory balances = token.balanceOfBatch(tos, ids);\n\n        assertEq(balances[0], 100);\n        assertEq(balances[1], 200);\n        assertEq(balances[2], 300);\n        assertEq(balances[3], 400);\n        assertEq(balances[4], 500);\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337, 1, "");\n    }\n\n    function testFailMintToNonERC155Recipient() public {\n        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToRevertingERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient() public {\n        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");\n    }\n\n    function testFailBurnInsufficientBalance() public {\n        token.mint(address(0xBEEF), 1337, 70, "");\n        token.burn(address(0xBEEF), 1337, 100);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337, 70, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance() public {\n        token.mint(address(this), 1337, 70, "");\n        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");\n    }\n\n    function testFailSafeTransferFromToZero() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(0), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {\n        token.mint(address(this), 1337, 100, "");\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 100;\n        transferAmounts[1] = 200;\n        transferAmounts[2] = 300;\n        transferAmounts[3] = 400;\n        transferAmounts[4] = 500;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToZero() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n        transferAmounts[4] = 250;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {\n        address from = address(0xABCD);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory transferAmounts = new uint256;\n        transferAmounts[0] = 50;\n        transferAmounts[1] = 100;\n        transferAmounts[2] = 150;\n        transferAmounts[3] = 200;\n\n        token.batchMint(from, ids, mintAmounts, "");\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");\n    }\n\n    function testFailBatchMintToZero() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(0), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToNonERC1155Recipient() public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient() public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        token.batchMint(address(to), ids, mintAmounts, "");\n    }\n\n    function testFailBatchMintWithArrayMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory amounts = new uint256;\n        amounts[0] = 100;\n        amounts[1] = 200;\n        amounts[2] = 300;\n        amounts[3] = 400;\n\n        token.batchMint(address(0xBEEF), ids, amounts, "");\n    }\n\n    function testFailBatchBurnInsufficientBalance() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 50;\n        mintAmounts[1] = 100;\n        mintAmounts[2] = 150;\n        mintAmounts[3] = 200;\n        mintAmounts[4] = 250;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 100;\n        burnAmounts[1] = 200;\n        burnAmounts[2] = 300;\n        burnAmounts[3] = 400;\n        burnAmounts[4] = 500;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch() public {\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n        ids[4] = 1341;\n\n        uint256[] memory mintAmounts = new uint256;\n        mintAmounts[0] = 100;\n        mintAmounts[1] = 200;\n        mintAmounts[2] = 300;\n        mintAmounts[3] = 400;\n        mintAmounts[4] = 500;\n\n        uint256[] memory burnAmounts = new uint256;\n        burnAmounts[0] = 50;\n        burnAmounts[1] = 100;\n        burnAmounts[2] = 150;\n        burnAmounts[3] = 200;\n\n        token.batchMint(address(0xBEEF), ids, mintAmounts, "");\n\n        token.batchBurn(address(0xBEEF), ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch() public view {\n        address[] memory tos = new address;\n        tos[0] = address(0xBEEF);\n        tos[1] = address(0xCAFE);\n        tos[2] = address(0xFACE);\n        tos[3] = address(0xDEAD);\n        tos[4] = address(0xFEED);\n\n        uint256[] memory ids = new uint256;\n        ids[0] = 1337;\n        ids[1] = 1338;\n        ids[2] = 1339;\n        ids[3] = 1340;\n\n        token.balanceOfBatch(tos, ids);\n    }\n\n    function testMintToEOA(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        token.mint(to, id, amount, mintData);\n\n        assertEq(token.balanceOf(to, id), amount);\n    }\n\n    function testMintToERC1155Recipient(\n        uint256 id,\n        uint256 amount,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        token.mint(address(to), id, amount, mintData);\n\n        assertEq(token.balanceOf(address(to), id), amount);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), mintData);\n    }\n\n    function testBatchMintToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);\n        }\n    }\n\n    function testBatchMintToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), address(0));\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);\n        assertBytesEq(to.batchData(), mintData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);\n        }\n    }\n\n    function testBurn(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 burnAmount\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(to, id, mintAmount, mintData);\n\n        token.burn(to, id, burnAmount);\n\n        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);\n    }\n\n    function testBatchBurn(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);\n\n            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];\n            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);\n        }\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testSafeTransferFromToEOA(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        address from = address(0xABCD);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromToERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        bytes memory transferData\n    ) public {\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), from);\n        assertEq(to.id(), id);\n        assertBytesEq(to.mintData(), transferData);\n\n        assertEq(token.balanceOf(address(to), id), transferAmount);\n        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);\n    }\n\n    function testSafeTransferFromSelf(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData,\n        uint256 transferAmount,\n        address to,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n\n        assertEq(token.balanceOf(to, id), transferAmount);\n        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);\n    }\n\n    function testSafeBatchTransferFromToEOA(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;\n\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n\n            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);\n        }\n    }\n\n    function testSafeBatchTransferFromToERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        ERC1155Recipient to = new ERC1155Recipient();\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n            userTransferOrBurnAmounts[from][id] += transferAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);\n\n        assertEq(to.batchOperator(), address(this));\n        assertEq(to.batchFrom(), from);\n        assertUintArrayEq(to.batchIds(), normalizedIds);\n        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);\n        assertBytesEq(to.batchData(), transferData);\n\n        for (uint256 i = 0; i &lt; normalizedIds.length; i++) {\n            uint256 id = normalizedIds[i];\n            uint256 transferAmount = userTransferOrBurnAmounts[from][id];\n\n            assertEq(token.balanceOf(address(to), id), transferAmount);\n            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);\n        }\n    }\n\n    function testBatchBalanceOf(\n        address[] memory tos,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(tos.length, ids.length, amounts.length);\n\n        address[] memory normalizedTos = new address;\n        uint256[] memory normalizedIds = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedTos[i] = to;\n            normalizedIds[i] = id;\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            token.mint(to, id, mintAmount, mintData);\n\n            userMintAmounts[to][id] += mintAmount;\n        }\n\n        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);\n\n        for (uint256 i = 0; i &lt; normalizedTos.length; i++) {\n            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));\n        }\n    }\n\n    function testFailMintToZero(\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public {\n        token.mint(address(0), id, amount, data);\n    }\n\n    function testFailMintToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToRevertingERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailMintToWrongReturnDataERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        bytes memory mintData\n    ) public {\n        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 burnAmount,\n        bytes memory mintData\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, id, mintAmount, mintData);\n        token.burn(to, id, burnAmount);\n    }\n\n    function testFailSafeTransferFromInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(from, id, mintAmount, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromSelfInsufficientBalance(\n        address to,\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToZero(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToNonERC155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);\n    }\n\n    function testFailSafeTransferFromToRevertingERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new RevertingERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(\n        uint256 id,\n        uint256 mintAmount,\n        uint256 transferAmount,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        transferAmount = bound(transferAmount, 0, mintAmount);\n\n        token.mint(address(this), id, mintAmount, mintData);\n        token.safeTransferFrom(\n            address(this),\n            address(new WrongReturnDataERC1155Recipient()),\n            id,\n            transferAmount,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToZero(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);\n    }\n\n    function testFailSafeBatchTransferFromToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new NonERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new RevertingERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedTransferAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];\n\n            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = mintAmount;\n            normalizedTransferAmounts[i] = transferAmount;\n\n            userMintAmounts[from][id] += mintAmount;\n        }\n\n        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(\n            from,\n            address(new WrongReturnDataERC1155Recipient()),\n            normalizedIds,\n            normalizedTransferAmounts,\n            transferData\n        );\n    }\n\n    function testFailSafeBatchTransferFromWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory transferAmounts,\n        bytes memory mintData,\n        bytes memory transferData\n    ) public {\n        address from = address(0xABCD);\n\n        if (ids.length == transferAmounts.length) revert();\n\n        token.batchMint(from, ids, mintAmounts, mintData);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);\n    }\n\n    function testFailBatchMintToZero(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(0)][id] += mintAmount;\n        }\n\n        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToNonERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        NonERC1155Recipient to = new NonERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToRevertingERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        RevertingERC1155Recipient to = new RevertingERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintToWrongReturnDataERC1155Recipient(\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();\n\n        uint256 minLength = min2(ids.length, amounts.length);\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];\n\n            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);\n\n            normalizedIds[i] = id;\n            normalizedAmounts[i] = mintAmount;\n\n            userMintAmounts[address(to)][id] += mintAmount;\n        }\n\n        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);\n    }\n\n    function testFailBatchMintWithArrayMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == amounts.length) revert();\n\n        token.batchMint(address(to), ids, amounts, mintData);\n    }\n\n    function testFailBatchBurnInsufficientBalance(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);\n\n        if (minLength == 0) revert();\n\n        uint256[] memory normalizedIds = new uint256;\n        uint256[] memory normalizedMintAmounts = new uint256;\n        uint256[] memory normalizedBurnAmounts = new uint256;\n\n        for (uint256 i = 0; i &lt; minLength; i++) {\n            uint256 id = ids[i];\n\n            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];\n\n            normalizedIds[i] = id;\n            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);\n            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);\n\n            userMintAmounts[to][id] += normalizedMintAmounts[i];\n        }\n\n        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);\n\n        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);\n    }\n\n    function testFailBatchBurnWithArrayLengthMismatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory mintAmounts,\n        uint256[] memory burnAmounts,\n        bytes memory mintData\n    ) public {\n        if (ids.length == burnAmounts.length) revert();\n\n        token.batchMint(to, ids, mintAmounts, mintData);\n\n        token.batchBurn(to, ids, burnAmounts);\n    }\n\n    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {\n        if (tos.length == ids.length) revert();\n\n        token.balanceOfBatch(tos, ids);\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-30-08 23:03:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0-only pragma solidity 0.8.10; import {DSTestPlus} from "./utils/DSTestPlus.sol"; import {DSInvariantTest} from "./utils/DSInvariantTest.sol"; import {MockERC1155} from "./utils/mocks/MockERC1155.sol"; import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol"; contract ERC1155Recipient is ERC1155TokenReceiver {     address public operator;     address public from;     uint256 public id;     uint256 public amount;     bytes public mintData; function onERC1155Received(     address _operator,     address _from,     uint256 _id,     uint256 _amount,     bytes calldata _data ) public override returns (bytes4) {     operator = _operator;     from = _from;     id = _id;     amount = _amount;     mintData = _data;      return ERC1155TokenReceiver.onERC1155Received.selector; }  address public batchOperator; address public batchFrom; uint256[] internal _batchIds; uint256[] internal _batchAmounts; bytes public batchData;  function batchIds() external view returns (uint256[] memory) {     return _batchIds; }  function batchAmounts() external view returns (uint256[] memory) {     return _batchAmounts; }  function onERC1155BatchReceived(     address _operator,     address _from,     uint256[] calldata _ids,     uint256[] calldata _amounts,     bytes calldata _data ) external override returns (bytes4) {     batchOperator = _operator;     batchFrom = _from;     _batchIds = _ids;     _batchAmounts = _amounts;     batchData = _data;      return ERC1155TokenReceiver.onERC1155BatchReceived.selector; }  } contract RevertingERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector))); }  } contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {     function onERC1155Received(         address,         address,         uint256,         uint256,         bytes calldata     ) public pure override returns (bytes4) {         return 0xCAFEBEEF;     } function onERC1155BatchReceived(     address,     address,     uint256[] calldata,     uint256[] calldata,     bytes calldata ) external pure override returns (bytes4) {     return 0xCAFEBEEF; }  } contract NonERC1155Recipient {} contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {     MockERC1155 token; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userMintAmounts; mapping(address =&gt; mapping(uint256 =&gt; uint256)) public userTransferOrBurnAmounts;  function setUp() public {     token = new MockERC1155(); }  function testMintToEOA() public {     token.mint(address(0xBEEF), 1337, 1, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 1); }  function testMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), 1337, 1, "testing 123");      assertEq(token.balanceOf(address(to), 1337), 1);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123"); }  function testBatchMintToEOA() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(0xBEEF), ids, amounts, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 200);     assertEq(token.balanceOf(address(0xBEEF), 1339), 300);     assertEq(token.balanceOf(address(0xBEEF), 1340), 400);     assertEq(token.balanceOf(address(0xBEEF), 1341), 500); }  function testBatchMintToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](5);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;     amounts[4] = 500;      token.batchMint(address(to), ids, amounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), amounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 100);     assertEq(token.balanceOf(address(to), 1338), 200);     assertEq(token.balanceOf(address(to), 1339), 300);     assertEq(token.balanceOf(address(to), 1340), 400);     assertEq(token.balanceOf(address(to), 1341), 500); }  function testBurn() public {     token.mint(address(0xBEEF), 1337, 100, "");      token.burn(address(0xBEEF), 1337, 70);      assertEq(token.balanceOf(address(0xBEEF), 1337), 30); }  function testBatchBurn() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;     burnAmounts[4] = 250;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts);      assertEq(token.balanceOf(address(0xBEEF), 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testApproveAll() public {     token.setApprovalForAll(address(0xBEEF), true);      assertTrue(token.isApprovedForAll(address(this), address(0xBEEF))); }  function testSafeTransferFromToEOA() public {     address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromToERC1155Recipient() public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      token.mint(from, 1337, 100, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), 1337);     assertBytesEq(to.mintData(), "testing 123");      assertEq(token.balanceOf(address(to), 1337), 70);     assertEq(token.balanceOf(from, 1337), 30); }  function testSafeTransferFromSelf() public {     token.mint(address(this), 1337, 100, "");      token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");      assertEq(token.balanceOf(address(0xBEEF), 1337), 70);     assertEq(token.balanceOf(address(this), 1337), 30); }  function testSafeBatchTransferFromToEOA() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(0xBEEF), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(0xBEEF), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(0xBEEF), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(0xBEEF), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(0xBEEF), 1341), 250); }  function testSafeBatchTransferFromToERC1155Recipient() public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), ids);     assertUintArrayEq(to.batchAmounts(), transferAmounts);     assertBytesEq(to.batchData(), "testing 123");      assertEq(token.balanceOf(from, 1337), 50);     assertEq(token.balanceOf(address(to), 1337), 50);      assertEq(token.balanceOf(from, 1338), 100);     assertEq(token.balanceOf(address(to), 1338), 100);      assertEq(token.balanceOf(from, 1339), 150);     assertEq(token.balanceOf(address(to), 1339), 150);      assertEq(token.balanceOf(from, 1340), 200);     assertEq(token.balanceOf(address(to), 1340), 200);      assertEq(token.balanceOf(from, 1341), 250);     assertEq(token.balanceOf(address(to), 1341), 250); }  function testBatchBalanceOf() public {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      token.mint(address(0xBEEF), 1337, 100, "");     token.mint(address(0xCAFE), 1338, 200, "");     token.mint(address(0xFACE), 1339, 300, "");     token.mint(address(0xDEAD), 1340, 400, "");     token.mint(address(0xFEED), 1341, 500, "");      uint256[] memory balances = token.balanceOfBatch(tos, ids);      assertEq(balances[0], 100);     assertEq(balances[1], 200);     assertEq(balances[2], 300);     assertEq(balances[3], 400);     assertEq(balances[4], 500); }  function testFailMintToZero() public {     token.mint(address(0), 1337, 1, ""); }  function testFailMintToNonERC155Recipient() public {     token.mint(address(new NonERC1155Recipient()), 1337, 1, ""); }  function testFailMintToRevertingERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailMintToWrongReturnDataERC155Recipient() public {     token.mint(address(new RevertingERC1155Recipient()), 1337, 1, ""); }  function testFailBurnInsufficientBalance() public {     token.mint(address(0xBEEF), 1337, 70, "");     token.burn(address(0xBEEF), 1337, 100); }  function testFailSafeTransferFromInsufficientBalance() public {     address from = address(0xABCD);      token.mint(from, 1337, 70, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromSelfInsufficientBalance() public {     token.mint(address(this), 1337, 70, "");     token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, ""); }  function testFailSafeTransferFromToZero() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(0), 1337, 70, ""); }  function testFailSafeTransferFromToNonERC155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToRevertingERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, ""); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {     token.mint(address(this), 1337, 100, "");     token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, ""); }  function testFailSafeBatchTransferInsufficientBalance() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);      mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 100;     transferAmounts[1] = 200;     transferAmounts[2] = 300;     transferAmounts[3] = 400;     transferAmounts[4] = 500;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToZero() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToNonERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](5);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;     transferAmounts[4] = 250;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, ""); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {     address from = address(0xABCD);      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory transferAmounts = new uint256[](4);     transferAmounts[0] = 50;     transferAmounts[1] = 100;     transferAmounts[2] = 150;     transferAmounts[3] = 200;      token.batchMint(from, ids, mintAmounts, "");      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, ""); }  function testFailBatchMintToZero() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(0), ids, mintAmounts, ""); }  function testFailBatchMintToNonERC1155Recipient() public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToRevertingERC1155Recipient() public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintToWrongReturnDataERC1155Recipient() public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      token.batchMint(address(to), ids, mintAmounts, ""); }  function testFailBatchMintWithArrayMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory amounts = new uint256[](4);     amounts[0] = 100;     amounts[1] = 200;     amounts[2] = 300;     amounts[3] = 400;      token.batchMint(address(0xBEEF), ids, amounts, ""); }  function testFailBatchBurnInsufficientBalance() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 50;     mintAmounts[1] = 100;     mintAmounts[2] = 150;     mintAmounts[3] = 200;     mintAmounts[4] = 250;      uint256[] memory burnAmounts = new uint256[](5);     burnAmounts[0] = 100;     burnAmounts[1] = 200;     burnAmounts[2] = 300;     burnAmounts[3] = 400;     burnAmounts[4] = 500;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch() public {     uint256[] memory ids = new uint256[](5);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;     ids[4] = 1341;      uint256[] memory mintAmounts = new uint256[](5);     mintAmounts[0] = 100;     mintAmounts[1] = 200;     mintAmounts[2] = 300;     mintAmounts[3] = 400;     mintAmounts[4] = 500;      uint256[] memory burnAmounts = new uint256[](4);     burnAmounts[0] = 50;     burnAmounts[1] = 100;     burnAmounts[2] = 150;     burnAmounts[3] = 200;      token.batchMint(address(0xBEEF), ids, mintAmounts, "");      token.batchBurn(address(0xBEEF), ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch() public view {     address[] memory tos = new address[](5);     tos[0] = address(0xBEEF);     tos[1] = address(0xCAFE);     tos[2] = address(0xFACE);     tos[3] = address(0xDEAD);     tos[4] = address(0xFEED);      uint256[] memory ids = new uint256[](4);     ids[0] = 1337;     ids[1] = 1338;     ids[2] = 1339;     ids[3] = 1340;      token.balanceOfBatch(tos, ids); }  function testMintToEOA(     address to,     uint256 id,     uint256 amount,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      token.mint(to, id, amount, mintData);      assertEq(token.balanceOf(to, id), amount); }  function testMintToERC1155Recipient(     uint256 id,     uint256 amount,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      token.mint(address(to), id, amount, mintData);      assertEq(token.balanceOf(address(to), id), amount);      assertEq(to.operator(), address(this));     assertEq(to.from(), address(0));     assertEq(to.id(), id);     assertBytesEq(to.mintData(), mintData); }  function testBatchMintToEOA(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[to][id] += mintAmount;     }      token.batchMint(to, normalizedIds, normalizedAmounts, mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);     } }  function testBatchMintToERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), address(0));     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedAmounts);     assertBytesEq(to.batchData(), mintData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);     } }  function testBurn(     address to,     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 burnAmount ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      burnAmount = bound(burnAmount, 0, mintAmount);      token.mint(to, id, mintAmount, mintData);      token.burn(to, id, burnAmount);      assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount); }  function testBatchBurn(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);          userMintAmounts[address(to)][id] += normalizedMintAmounts[i];         userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);     } }  function testApproveAll(address to, bool approved) public {     token.setApprovalForAll(to, approved);      assertBoolEq(token.isApprovedForAll(address(this), to), approved); }  function testSafeTransferFromToEOA(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      address from = address(0xABCD);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromToERC1155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     bytes memory transferData ) public {     ERC1155Recipient to = new ERC1155Recipient();      address from = address(0xABCD);      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, address(to), id, transferAmount, transferData);      assertEq(to.operator(), address(this));     assertEq(to.from(), from);     assertEq(to.id(), id);     assertBytesEq(to.mintData(), transferData);      assertEq(token.balanceOf(address(to), id), transferAmount);     assertEq(token.balanceOf(from, id), mintAmount - transferAmount); }  function testSafeTransferFromSelf(     uint256 id,     uint256 mintAmount,     bytes memory mintData,     uint256 transferAmount,     address to,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);      token.safeTransferFrom(address(this), to, id, transferAmount, transferData);      assertEq(token.balanceOf(to, id), transferAmount);     assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount); }  function testSafeBatchTransferFromToEOA(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     if (to == address(0)) to = address(0xBEEF);      if (uint256(uint160(to)) &lt;= 18 || to.code.length &gt; 0) return;      address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];          assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);     } }  function testSafeBatchTransferFromToERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      ERC1155Recipient to = new ERC1155Recipient();      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;         userTransferOrBurnAmounts[from][id] += transferAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);      assertEq(to.batchOperator(), address(this));     assertEq(to.batchFrom(), from);     assertUintArrayEq(to.batchIds(), normalizedIds);     assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);     assertBytesEq(to.batchData(), transferData);      for (uint256 i = 0; i &lt; normalizedIds.length; i++) {         uint256 id = normalizedIds[i];         uint256 transferAmount = userTransferOrBurnAmounts[from][id];          assertEq(token.balanceOf(address(to), id), transferAmount);         assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);     } }  function testBatchBalanceOf(     address[] memory tos,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min3(tos.length, ids.length, amounts.length);      address[] memory normalizedTos = new address[](minLength);     uint256[] memory normalizedIds = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];         address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedTos[i] = to;         normalizedIds[i] = id;          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          token.mint(to, id, mintAmount, mintData);          userMintAmounts[to][id] += mintAmount;     }      uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);      for (uint256 i = 0; i &lt; normalizedTos.length; i++) {         assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));     } }  function testFailMintToZero(     uint256 id,     uint256 amount,     bytes memory data ) public {     token.mint(address(0), id, amount, data); }  function testFailMintToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToRevertingERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailMintToWrongReturnDataERC155Recipient(     uint256 id,     uint256 mintAmount,     bytes memory mintData ) public {     token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData); }  function testFailBurnInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 burnAmount,     bytes memory mintData ) public {     burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);      token.mint(to, id, mintAmount, mintData);     token.burn(to, id, burnAmount); }  function testFailSafeTransferFromInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(from, id, mintAmount, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeTransferFrom(from, to, id, transferAmount, transferData); }  function testFailSafeTransferFromSelfInsufficientBalance(     address to,     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), to, id, transferAmount, transferData); }  function testFailSafeTransferFromToZero(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData); }  function testFailSafeTransferFromToNonERC155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData); }  function testFailSafeTransferFromToRevertingERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new RevertingERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(     uint256 id,     uint256 mintAmount,     uint256 transferAmount,     bytes memory mintData,     bytes memory transferData ) public {     transferAmount = bound(transferAmount, 0, mintAmount);      token.mint(address(this), id, mintAmount, mintData);     token.safeTransferFrom(         address(this),         address(new WrongReturnDataERC1155Recipient()),         id,         transferAmount,         transferData     ); }  function testFailSafeBatchTransferInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToZero(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData); }  function testFailSafeBatchTransferFromToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new NonERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new RevertingERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedTransferAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];          uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);         uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);          normalizedIds[i] = id;         normalizedMintAmounts[i] = mintAmount;         normalizedTransferAmounts[i] = transferAmount;          userMintAmounts[from][id] += mintAmount;     }      token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(         from,         address(new WrongReturnDataERC1155Recipient()),         normalizedIds,         normalizedTransferAmounts,         transferData     ); }  function testFailSafeBatchTransferFromWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory transferAmounts,     bytes memory mintData,     bytes memory transferData ) public {     address from = address(0xABCD);      if (ids.length == transferAmounts.length) revert();      token.batchMint(from, ids, mintAmounts, mintData);      hevm.prank(from);     token.setApprovalForAll(address(this), true);      token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData); }  function testFailBatchMintToZero(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(0)][id] += mintAmount;     }      token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToNonERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     NonERC1155Recipient to = new NonERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToRevertingERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     RevertingERC1155Recipient to = new RevertingERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintToWrongReturnDataERC1155Recipient(     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();      uint256 minLength = min2(ids.length, amounts.length);      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];          uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);          normalizedIds[i] = id;         normalizedAmounts[i] = mintAmount;          userMintAmounts[address(to)][id] += mintAmount;     }      token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData); }  function testFailBatchMintWithArrayMismatch(     address to,     uint256[] memory ids,     uint256[] memory amounts,     bytes memory mintData ) public {     if (ids.length == amounts.length) revert();      token.batchMint(address(to), ids, amounts, mintData); }  function testFailBatchBurnInsufficientBalance(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);      if (minLength == 0) revert();      uint256[] memory normalizedIds = new uint256[](minLength);     uint256[] memory normalizedMintAmounts = new uint256[](minLength);     uint256[] memory normalizedBurnAmounts = new uint256[](minLength);      for (uint256 i = 0; i &lt; minLength; i++) {         uint256 id = ids[i];          uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];          normalizedIds[i] = id;         normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);         normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);          userMintAmounts[to][id] += normalizedMintAmounts[i];     }      token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);      token.batchBurn(to, normalizedIds, normalizedBurnAmounts); }  function testFailBatchBurnWithArrayLengthMismatch(     address to,     uint256[] memory ids,     uint256[] memory mintAmounts,     uint256[] memory burnAmounts,     bytes memory mintData ) public {     if (ids.length == burnAmounts.length) revert();      token.batchMint(to, ids, mintAmounts, mintData);      token.batchBurn(to, ids, burnAmounts); }  function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {     if (tos.length == ids.length) revert();      token.balanceOfBatch(tos, ids); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-30-08 23:03:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {DSTestPlus} from "./utils/DSTestPlus.sol";
import {DSInvariantTest} from "./utils/DSInvariantTest.sol";

import {MockERC1155} from "./utils/mocks/MockERC1155.sol";

import {ERC1155TokenReceiver} from "../tokens/ERC1155.sol";

contract ERC1155Recipient is ERC1155TokenReceiver {
    address public operator;
    address public from;
    uint256 public id;
    uint256 public amount;
    bytes public mintData;

    function onERC1155Received(
        address _operator,
        address _from,
        uint256 _id,
        uint256 _amount,
        bytes calldata _data
    ) public override returns (bytes4) {
        operator = _operator;
        from = _from;
        id = _id;
        amount = _amount;
        mintData = _data;

        return ERC1155TokenReceiver.onERC1155Received.selector;
    }

    address public batchOperator;
    address public batchFrom;
    uint256[] internal _batchIds;
    uint256[] internal _batchAmounts;
    bytes public batchData;

    function batchIds() external view returns (uint256[] memory) {
        return _batchIds;
    }

    function batchAmounts() external view returns (uint256[] memory) {
        return _batchAmounts;
    }

    function onERC1155BatchReceived(
        address _operator,
        address _from,
        uint256[] calldata _ids,
        uint256[] calldata _amounts,
        bytes calldata _data
    ) external override returns (bytes4) {
        batchOperator = _operator;
        batchFrom = _from;
        _batchIds = _ids;
        _batchAmounts = _amounts;
        batchData = _data;

        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;
    }
}

contract RevertingERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155Received.selector)));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        revert(string(abi.encodePacked(ERC1155TokenReceiver.onERC1155BatchReceived.selector)));
    }
}

contract WrongReturnDataERC1155Recipient is ERC1155TokenReceiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) public pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return 0xCAFEBEEF;
    }
}

contract NonERC1155Recipient {}

contract ERC1155Test is DSTestPlus, ERC1155TokenReceiver {
    MockERC1155 token;

    mapping(address => mapping(uint256 => uint256)) public userMintAmounts;
    mapping(address => mapping(uint256 => uint256)) public userTransferOrBurnAmounts;

    function setUp() public {
        token = new MockERC1155();
    }

    function testMintToEOA() public {
        token.mint(address(0xBEEF), 1337, 1, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 1);
    }

    function testMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), 1337, 1, "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 1);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");
    }

    function testBatchMintToEOA() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, amounts, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 300);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 400);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 500);
    }

    function testBatchMintToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;
        amounts[4] = 500;

        token.batchMint(address(to), ids, amounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), amounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 100);
        assertEq(token.balanceOf(address(to), 1338), 200);
        assertEq(token.balanceOf(address(to), 1339), 300);
        assertEq(token.balanceOf(address(to), 1340), 400);
        assertEq(token.balanceOf(address(to), 1341), 500);
    }

    function testBurn() public {
        token.mint(address(0xBEEF), 1337, 100, "");

        token.burn(address(0xBEEF), 1337, 70);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 30);
    }

    function testBatchBurn() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;
        burnAmounts[4] = 250;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);

        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testApproveAll() public {
        token.setApprovalForAll(address(0xBEEF), true);

        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));
    }

    function testSafeTransferFromToEOA() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromToERC1155Recipient() public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        token.mint(from, 1337, 100, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), 1337, 70, "testing 123");

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), 1337);
        assertBytesEq(to.mintData(), "testing 123");

        assertEq(token.balanceOf(address(to), 1337), 70);
        assertEq(token.balanceOf(from, 1337), 30);
    }

    function testSafeTransferFromSelf() public {
        token.mint(address(this), 1337, 100, "");

        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 70, "");

        assertEq(token.balanceOf(address(0xBEEF), 1337), 70);
        assertEq(token.balanceOf(address(this), 1337), 30);
    }

    function testSafeBatchTransferFromToEOA() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(0xBEEF), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(0xBEEF), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(0xBEEF), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(0xBEEF), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(0xBEEF), 1341), 250);
    }

    function testSafeBatchTransferFromToERC1155Recipient() public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), ids, transferAmounts, "testing 123");

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), ids);
        assertUintArrayEq(to.batchAmounts(), transferAmounts);
        assertBytesEq(to.batchData(), "testing 123");

        assertEq(token.balanceOf(from, 1337), 50);
        assertEq(token.balanceOf(address(to), 1337), 50);

        assertEq(token.balanceOf(from, 1338), 100);
        assertEq(token.balanceOf(address(to), 1338), 100);

        assertEq(token.balanceOf(from, 1339), 150);
        assertEq(token.balanceOf(address(to), 1339), 150);

        assertEq(token.balanceOf(from, 1340), 200);
        assertEq(token.balanceOf(address(to), 1340), 200);

        assertEq(token.balanceOf(from, 1341), 250);
        assertEq(token.balanceOf(address(to), 1341), 250);
    }

    function testBatchBalanceOf() public {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        token.mint(address(0xBEEF), 1337, 100, "");
        token.mint(address(0xCAFE), 1338, 200, "");
        token.mint(address(0xFACE), 1339, 300, "");
        token.mint(address(0xDEAD), 1340, 400, "");
        token.mint(address(0xFEED), 1341, 500, "");

        uint256[] memory balances = token.balanceOfBatch(tos, ids);

        assertEq(balances[0], 100);
        assertEq(balances[1], 200);
        assertEq(balances[2], 300);
        assertEq(balances[3], 400);
        assertEq(balances[4], 500);
    }

    function testFailMintToZero() public {
        token.mint(address(0), 1337, 1, "");
    }

    function testFailMintToNonERC155Recipient() public {
        token.mint(address(new NonERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToRevertingERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailMintToWrongReturnDataERC155Recipient() public {
        token.mint(address(new RevertingERC1155Recipient()), 1337, 1, "");
    }

    function testFailBurnInsufficientBalance() public {
        token.mint(address(0xBEEF), 1337, 70, "");
        token.burn(address(0xBEEF), 1337, 100);
    }

    function testFailSafeTransferFromInsufficientBalance() public {
        address from = address(0xABCD);

        token.mint(from, 1337, 70, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromSelfInsufficientBalance() public {
        token.mint(address(this), 1337, 70, "");
        token.safeTransferFrom(address(this), address(0xBEEF), 1337, 100, "");
    }

    function testFailSafeTransferFromToZero() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(0), 1337, 70, "");
    }

    function testFailSafeTransferFromToNonERC155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new RevertingERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient() public {
        token.mint(address(this), 1337, 100, "");
        token.safeTransferFrom(address(this), address(new WrongReturnDataERC1155Recipient()), 1337, 70, "");
    }

    function testFailSafeBatchTransferInsufficientBalance() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);

        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 100;
        transferAmounts[1] = 200;
        transferAmounts[2] = 300;
        transferAmounts[3] = 400;
        transferAmounts[4] = 500;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToZero() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new NonERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new RevertingERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](5);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;
        transferAmounts[4] = 250;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(new WrongReturnDataERC1155Recipient()), ids, transferAmounts, "");
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch() public {
        address from = address(0xABCD);

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory transferAmounts = new uint256[](4);
        transferAmounts[0] = 50;
        transferAmounts[1] = 100;
        transferAmounts[2] = 150;
        transferAmounts[3] = 200;

        token.batchMint(from, ids, mintAmounts, "");

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0xBEEF), ids, transferAmounts, "");
    }

    function testFailBatchMintToZero() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(0), ids, mintAmounts, "");
    }

    function testFailBatchMintToNonERC1155Recipient() public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToRevertingERC1155Recipient() public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient() public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        token.batchMint(address(to), ids, mintAmounts, "");
    }

    function testFailBatchMintWithArrayMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory amounts = new uint256[](4);
        amounts[0] = 100;
        amounts[1] = 200;
        amounts[2] = 300;
        amounts[3] = 400;

        token.batchMint(address(0xBEEF), ids, amounts, "");
    }

    function testFailBatchBurnInsufficientBalance() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 50;
        mintAmounts[1] = 100;
        mintAmounts[2] = 150;
        mintAmounts[3] = 200;
        mintAmounts[4] = 250;

        uint256[] memory burnAmounts = new uint256[](5);
        burnAmounts[0] = 100;
        burnAmounts[1] = 200;
        burnAmounts[2] = 300;
        burnAmounts[3] = 400;
        burnAmounts[4] = 500;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch() public {
        uint256[] memory ids = new uint256[](5);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;
        ids[4] = 1341;

        uint256[] memory mintAmounts = new uint256[](5);
        mintAmounts[0] = 100;
        mintAmounts[1] = 200;
        mintAmounts[2] = 300;
        mintAmounts[3] = 400;
        mintAmounts[4] = 500;

        uint256[] memory burnAmounts = new uint256[](4);
        burnAmounts[0] = 50;
        burnAmounts[1] = 100;
        burnAmounts[2] = 150;
        burnAmounts[3] = 200;

        token.batchMint(address(0xBEEF), ids, mintAmounts, "");

        token.batchBurn(address(0xBEEF), ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch() public view {
        address[] memory tos = new address[](5);
        tos[0] = address(0xBEEF);
        tos[1] = address(0xCAFE);
        tos[2] = address(0xFACE);
        tos[3] = address(0xDEAD);
        tos[4] = address(0xFEED);

        uint256[] memory ids = new uint256[](4);
        ids[0] = 1337;
        ids[1] = 1338;
        ids[2] = 1339;
        ids[3] = 1340;

        token.balanceOfBatch(tos, ids);
    }

    function testMintToEOA(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        token.mint(to, id, amount, mintData);

        assertEq(token.balanceOf(to, id), amount);
    }

    function testMintToERC1155Recipient(
        uint256 id,
        uint256 amount,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        token.mint(address(to), id, amount, mintData);

        assertEq(token.balanceOf(address(to), id), amount);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), address(0));
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), mintData);
    }

    function testBatchMintToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[to][id] += mintAmount;
        }

        token.batchMint(to, normalizedIds, normalizedAmounts, mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id]);
        }
    }

    function testBatchMintToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), address(0));
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedAmounts);
        assertBytesEq(to.batchData(), mintData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userMintAmounts[address(to)][id]);
        }
    }

    function testBurn(
        address to,
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 burnAmount
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        burnAmount = bound(burnAmount, 0, mintAmount);

        token.mint(to, id, mintAmount, mintData);

        token.burn(to, id, burnAmount);

        assertEq(token.balanceOf(address(to), id), mintAmount - burnAmount);
    }

    function testBatchBurn(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], 0, normalizedMintAmounts[i]);

            userMintAmounts[address(to)][id] += normalizedMintAmounts[i];
            userTransferOrBurnAmounts[address(to)][id] += normalizedBurnAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(to, id), userMintAmounts[to][id] - userTransferOrBurnAmounts[to][id]);
        }
    }

    function testApproveAll(address to, bool approved) public {
        token.setApprovalForAll(to, approved);

        assertBoolEq(token.isApprovedForAll(address(this), to), approved);
    }

    function testSafeTransferFromToEOA(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        address from = address(0xABCD);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromToERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        bytes memory transferData
    ) public {
        ERC1155Recipient to = new ERC1155Recipient();

        address from = address(0xABCD);

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, address(to), id, transferAmount, transferData);

        assertEq(to.operator(), address(this));
        assertEq(to.from(), from);
        assertEq(to.id(), id);
        assertBytesEq(to.mintData(), transferData);

        assertEq(token.balanceOf(address(to), id), transferAmount);
        assertEq(token.balanceOf(from, id), mintAmount - transferAmount);
    }

    function testSafeTransferFromSelf(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData,
        uint256 transferAmount,
        address to,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);

        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);

        assertEq(token.balanceOf(to, id), transferAmount);
        assertEq(token.balanceOf(address(this), id), mintAmount - transferAmount);
    }

    function testSafeBatchTransferFromToEOA(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        if (to == address(0)) to = address(0xBEEF);

        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;

        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];

            assertEq(token.balanceOf(address(to), id), userTransferOrBurnAmounts[from][id]);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - userTransferOrBurnAmounts[from][id]);
        }
    }

    function testSafeBatchTransferFromToERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        ERC1155Recipient to = new ERC1155Recipient();

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
            userTransferOrBurnAmounts[from][id] += transferAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(to), normalizedIds, normalizedTransferAmounts, transferData);

        assertEq(to.batchOperator(), address(this));
        assertEq(to.batchFrom(), from);
        assertUintArrayEq(to.batchIds(), normalizedIds);
        assertUintArrayEq(to.batchAmounts(), normalizedTransferAmounts);
        assertBytesEq(to.batchData(), transferData);

        for (uint256 i = 0; i < normalizedIds.length; i++) {
            uint256 id = normalizedIds[i];
            uint256 transferAmount = userTransferOrBurnAmounts[from][id];

            assertEq(token.balanceOf(address(to), id), transferAmount);
            assertEq(token.balanceOf(from, id), userMintAmounts[from][id] - transferAmount);
        }
    }

    function testBatchBalanceOf(
        address[] memory tos,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(tos.length, ids.length, amounts.length);

        address[] memory normalizedTos = new address[](minLength);
        uint256[] memory normalizedIds = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];
            address to = tos[i] == address(0) ? address(0xBEEF) : tos[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedTos[i] = to;
            normalizedIds[i] = id;

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            token.mint(to, id, mintAmount, mintData);

            userMintAmounts[to][id] += mintAmount;
        }

        uint256[] memory balances = token.balanceOfBatch(normalizedTos, normalizedIds);

        for (uint256 i = 0; i < normalizedTos.length; i++) {
            assertEq(balances[i], token.balanceOf(normalizedTos[i], normalizedIds[i]));
        }
    }

    function testFailMintToZero(
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        token.mint(address(0), id, amount, data);
    }

    function testFailMintToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new NonERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToRevertingERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailMintToWrongReturnDataERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        bytes memory mintData
    ) public {
        token.mint(address(new RevertingERC1155Recipient()), id, mintAmount, mintData);
    }

    function testFailBurnInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 burnAmount,
        bytes memory mintData
    ) public {
        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);

        token.mint(to, id, mintAmount, mintData);
        token.burn(to, id, burnAmount);
    }

    function testFailSafeTransferFromInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(from, id, mintAmount, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeTransferFrom(from, to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromSelfInsufficientBalance(
        address to,
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, mintAmount + 1, type(uint256).max);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), to, id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToZero(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(0), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToNonERC155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(address(this), address(new NonERC1155Recipient()), id, transferAmount, transferData);
    }

    function testFailSafeTransferFromToRevertingERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new RevertingERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeTransferFromToWrongReturnDataERC1155Recipient(
        uint256 id,
        uint256 mintAmount,
        uint256 transferAmount,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        transferAmount = bound(transferAmount, 0, mintAmount);

        token.mint(address(this), id, mintAmount, mintData);
        token.safeTransferFrom(
            address(this),
            address(new WrongReturnDataERC1155Recipient()),
            id,
            transferAmount,
            transferData
        );
    }

    function testFailSafeBatchTransferInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], mintAmount + 1, type(uint256).max);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToZero(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, address(0), normalizedIds, normalizedTransferAmounts, transferData);
    }

    function testFailSafeBatchTransferFromToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new NonERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new RevertingERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        uint256 minLength = min3(ids.length, mintAmounts.length, transferAmounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedTransferAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[from][id];

            uint256 mintAmount = bound(mintAmounts[i], 0, remainingMintAmountForId);
            uint256 transferAmount = bound(transferAmounts[i], 0, mintAmount);

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = mintAmount;
            normalizedTransferAmounts[i] = transferAmount;

            userMintAmounts[from][id] += mintAmount;
        }

        token.batchMint(from, normalizedIds, normalizedMintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(
            from,
            address(new WrongReturnDataERC1155Recipient()),
            normalizedIds,
            normalizedTransferAmounts,
            transferData
        );
    }

    function testFailSafeBatchTransferFromWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory transferAmounts,
        bytes memory mintData,
        bytes memory transferData
    ) public {
        address from = address(0xABCD);

        if (ids.length == transferAmounts.length) revert();

        token.batchMint(from, ids, mintAmounts, mintData);

        hevm.prank(from);
        token.setApprovalForAll(address(this), true);

        token.safeBatchTransferFrom(from, to, ids, transferAmounts, transferData);
    }

    function testFailBatchMintToZero(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(0)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(0)][id] += mintAmount;
        }

        token.batchMint(address(0), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToNonERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        NonERC1155Recipient to = new NonERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToRevertingERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        RevertingERC1155Recipient to = new RevertingERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintToWrongReturnDataERC1155Recipient(
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        WrongReturnDataERC1155Recipient to = new WrongReturnDataERC1155Recipient();

        uint256 minLength = min2(ids.length, amounts.length);

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[address(to)][id];

            uint256 mintAmount = bound(amounts[i], 0, remainingMintAmountForId);

            normalizedIds[i] = id;
            normalizedAmounts[i] = mintAmount;

            userMintAmounts[address(to)][id] += mintAmount;
        }

        token.batchMint(address(to), normalizedIds, normalizedAmounts, mintData);
    }

    function testFailBatchMintWithArrayMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory mintData
    ) public {
        if (ids.length == amounts.length) revert();

        token.batchMint(address(to), ids, amounts, mintData);
    }

    function testFailBatchBurnInsufficientBalance(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        uint256 minLength = min3(ids.length, mintAmounts.length, burnAmounts.length);

        if (minLength == 0) revert();

        uint256[] memory normalizedIds = new uint256[](minLength);
        uint256[] memory normalizedMintAmounts = new uint256[](minLength);
        uint256[] memory normalizedBurnAmounts = new uint256[](minLength);

        for (uint256 i = 0; i < minLength; i++) {
            uint256 id = ids[i];

            uint256 remainingMintAmountForId = type(uint256).max - userMintAmounts[to][id];

            normalizedIds[i] = id;
            normalizedMintAmounts[i] = bound(mintAmounts[i], 0, remainingMintAmountForId);
            normalizedBurnAmounts[i] = bound(burnAmounts[i], normalizedMintAmounts[i] + 1, type(uint256).max);

            userMintAmounts[to][id] += normalizedMintAmounts[i];
        }

        token.batchMint(to, normalizedIds, normalizedMintAmounts, mintData);

        token.batchBurn(to, normalizedIds, normalizedBurnAmounts);
    }

    function testFailBatchBurnWithArrayLengthMismatch(
        address to,
        uint256[] memory ids,
        uint256[] memory mintAmounts,
        uint256[] memory burnAmounts,
        bytes memory mintData
    ) public {
        if (ids.length == burnAmounts.length) revert();

        token.batchMint(to, ids, mintAmounts, mintData);

        token.batchBurn(to, ids, burnAmounts);
    }

    function testFailBalanceOfBatchWithArrayMismatch(address[] memory tos, uint256[] memory ids) public view {
        if (tos.length == ids.length) revert();

        token.balanceOfBatch(tos, ids);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

