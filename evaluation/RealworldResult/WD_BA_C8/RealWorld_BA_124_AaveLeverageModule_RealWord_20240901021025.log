[2024-01-09 02:10:25 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901021025)

**Timestamp**: 20240901021025

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}

**project_name**: RealWorld_BA_124_AaveLeverageModule

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_124_AaveLeverageModule_RealWord_20240901021025.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 02:10:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n\n    / ============ Events ============ */\n\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ */\n\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n\n        Different states of the SetToken and what this function does in those states:\n\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n\n        Values of variables in below if condition and corresponding action taken:\n\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:26 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 02:10:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:10:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24254
completion_tokens: 1
total_tokens: 24255
cost: $-1.000000


[2024-01-09 02:10:29 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Let's

[2024-01-09 02:10:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: /\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n    / ============ Structs ============ /\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n    / ============ Events ============ */\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n    / ============ Constants ============ /\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n    / ============ Constructor ============ /\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n    / ============ External Functions ============ /\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n        _updateLeverPositions(leverInfo, _borrowAsset);\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n        return notionalRepayQuantity;\n    }\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n        delete enabledAssets[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            require(componentDebt &lt; 0, "Component must be negative");\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            require(componentDebt &lt; 0, "Component must be negative");\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n    / ============ External Getter Functions ============ /\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n    / ============ Internal Functions ============ */\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n        setToken.invoke(targetExchange, callValue, methodData);\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n        return receiveTokenQuantity;\n    }\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n        return protocolFeeTotal;\n    }\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n        _validateCommon(actionInfo);\n        return actionInfo;\n    }\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n        Different states of the SetToken and what this function does in those states:\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n        Values of variables in below if condition and corresponding action taken:\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "/\n    Copyright 2021 Set Labs Inc.\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n    / ============ Structs ============ /\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n    / ============ Events ============ /\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     */\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     /\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     */\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     /\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n    / ============ Constants ============ /\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n    / ============ State Variables ============ /\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n    / ============ Constructor ============ /\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n    / ============ External Functions ============ */\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     /\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n        _updateLeverPositions(leverInfo, _borrowAsset);\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     */\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n        return notionalRepayQuantity;\n    }\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     /\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n        // Initialize module before trying register\n        _setToken.initializeModule();\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     */\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n        delete enabledAssets[setToken];\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     /\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     */\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     /\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     */\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     /\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            require(componentDebt &lt; 0, "Component must be negative");\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n            require(componentDebt &lt; 0, "Component must be negative");\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n    / ============ External Getter Functions ============ */\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n    / ============ Internal Functions ============ /\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     */\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     /\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     */\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n        setToken.invoke(targetExchange, callValue, methodData);\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n        return receiveTokenQuantity;\n    }\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     */\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n        return protocolFeeTotal;\n    }\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     /\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     */\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     /\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     */\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n        _validateCommon(actionInfo);\n        return actionInfo;\n    }\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     /\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     */\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n        Different states of the SetToken and what this function does in those states:\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n        Values of variables in below if condition and corresponding action taken:\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        /\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     */\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     /\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     */\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:31 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;
    /* ============ Structs ============ */
    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }
    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }
    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }
    /* ============ Events ============ */
    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );
    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );
    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );
    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );
    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );
    /* ============ Constants ============ */
    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;
    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;
    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;
    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;
    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;
    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;
    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;
    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;
    /* ============ Constructor ============ */
    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;
        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }
    /* ============ External Functions ============ */
    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );
        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);
        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);
        _updateLeverPositions(leverInfo, _borrowAsset);
        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }
    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );
        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);
        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);
        _updateDeleverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }
    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);
        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");
        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );
        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);
        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);
        _updateDeleverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );
        return notionalRepayQuantity;
    }
    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();
        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);
                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }
    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }
        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }
    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);
        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");
            delete borrowAssetEnabled[setToken][borrowAsset];
        }
        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);
            delete collateralAssetEnabled[setToken][collateralAsset];
        }
        delete enabledAssets[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");
        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");
        _addUnderlyingToReserveTokensMapping(_underlying);
    }
    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }
    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");
            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);
            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }
    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }
    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];
            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");
            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }
    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }
    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            require(componentDebt < 0, "Component must be negative");
            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            require(componentDebt < 0, "Component must be negative");
            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }
    /* ============ External Getter Functions ============ */
    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }
    /* ============ Internal Functions ============ */
    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }
    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }
    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }
    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }
    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }
    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }
    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;
        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );
        setToken.invoke(targetExchange, callValue, methodData);
        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );
        return receiveTokenQuantity;
    }
    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);
        return protocolFeeTotal;
    }
    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );
        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }
    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }
        _updateLeverPositions(_actionInfo, _repayAsset);
    }
    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }
    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }
    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }
    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });
        _validateCommon(actionInfo);
        return actionInfo;
    }
    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);
        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }
    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];
            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);
            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }
    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];
            _validateNewBorrowAsset(_setToken, borrowAsset);
            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }
    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0
        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer
        Different states of the SetToken and what this function does in those states:
            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.
            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets
            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset
            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave
            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken
        Values of variables in below if condition and corresponding action taken:
        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }
    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }
    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");
        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");
        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }
    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");
        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");
        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }
    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }
    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "/*
    Copyright 2021 Set Labs Inc.
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    SPDX-License-Identifier: Apache License, Version 2.0
*/
pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";
/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;
    /* ============ Structs ============ */
    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }
    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }
    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }
    /* ============ Events ============ */
    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );
    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );
    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );
    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );
    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );
    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );
    /* ============ Constants ============ */
    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;
    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";
    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;
    /* ============ State Variables ============ */
    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;
    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;
    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;
    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;
    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;
    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;
    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;
    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;
    /* ============ Constructor ============ */
    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;
        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }
    /* ============ External Functions ============ */
    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );
        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);
        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);
        _updateLeverPositions(leverInfo, _borrowAsset);
        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }
    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );
        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);
        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);
        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);
        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);
        _updateDeleverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }
    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);
        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");
        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );
        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);
        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);
        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);
        _updateDeleverPositions(deleverInfo, _repayAsset);
        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );
        return notionalRepayQuantity;
    }
    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();
        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;
                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }
            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);
                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);
                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }
    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }
        // Initialize module before trying register
        _setToken.initializeModule();
        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");
        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }
        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }
    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);
        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);
        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");
            delete borrowAssetEnabled[setToken][borrowAsset];
        }
        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);
            delete collateralAssetEnabled[setToken][collateralAsset];
        }
        delete enabledAssets[setToken];
        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }
    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");
        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }
    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");
        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");
        _addUnderlyingToReserveTokensMapping(_underlying);
    }
    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }
    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");
            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);
            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }
    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }
    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {
        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];
            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");
            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }
    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }
    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            require(componentDebt < 0, "Component must be negative");
            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }
    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));
            require(componentDebt < 0, "Component must be negative");
            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }
    /* ============ External Getter Functions ============ */
    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }
    /* ============ Internal Functions ============ */
    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }
    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }
    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }
    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }
    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }
    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }
    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;
        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );
        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );
        setToken.invoke(targetExchange, callValue, methodData);
        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );
        return receiveTokenQuantity;
    }
    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);
        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);
        return protocolFeeTotal;
    }
    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );
        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }
    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }
        _updateLeverPositions(_actionInfo, _repayAsset);
    }
    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }
    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }
    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();
        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }
    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });
        _validateCommon(actionInfo);
        return actionInfo;
    }
    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);
        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }
    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];
            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);
            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }
    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];
            _validateNewBorrowAsset(_setToken, borrowAsset);
            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }
    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0
        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer
        Different states of the SetToken and what this function does in those states:
            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.
            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets
            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset
            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave
            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken
        Values of variables in below if condition and corresponding action taken:
        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }
    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }
    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");
        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");
        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }
    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");
        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");
        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }
    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }
    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 02:10:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:10:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 36436
completion_tokens: 1
total_tokens: 36437
cost: $-1.000000


[2024-01-09 02:10:35 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Security

[2024-01-09 02:10:35 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 02:10:35 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 02:10:35 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 02:10:36 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n\n    / ============ Events ============ */\n\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ */\n\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n\n        Different states of the SetToken and what this function does in those states:\n\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n\n        Values of variables in below if condition and corresponding action taken:\n\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:36 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:10:39 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:10:39 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24245
completion_tokens: 1
total_tokens: 24246
cost: $-1.000000


[2024-01-09 02:10:39 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

###

[2024-01-09 02:10:39 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:10:39 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 02:10:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:39 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:10:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:10:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12181
completion_tokens: 873
total_tokens: 13054
cost: $-1.000000


[2024-01-09 02:10:51 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Based on the provided Solidity smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`) that could potentially lead to reentrancy attacks if not properly managed. It is crucial to ensure that all state changes are made before any external calls.

2. **Slippage Risk**:
   - The `_executeTrade` function requires that the quantity of tokens received after a trade meets a minimum threshold. If the market experiences high volatility, there is a risk that the trade may not execute as expected, leading to potential losses.

3. **Access Control Issues**:
   - Functions that modify the state of the contract (e.g., `addCollateralAssets`, `removeCollateralAssets`, `lever`, `delever`) rely on the `onlyManagerAndValidSet` modifier. If this modifier is not robustly implemented, it could allow unauthorized users to execute sensitive functions.

4. **Gas Limit and Block Size Issues**:
   - The contract contains loops (e.g., in `sync` and asset management functions) that could consume significant gas if the number of assets grows large. This could lead to out-of-gas errors, preventing legitimate transactions from being processed.

5. **Improper Error Handling**:
   - The contract uses `require` statements for validation, but if any of these conditions fail, it may not provide sufficient context in the error messages. This could make debugging difficult for users.

6. **Potential for Front-Running**:
   - The contract's reliance on external price feeds and trading mechanisms could expose it to front-running attacks, where malicious actors exploit the timing of transactions to gain an advantage.

7. **Lack of Input Validation**:
   - Functions that accept external inputs (e.g., asset addresses) do not perform thorough validation to ensure that the inputs are valid ERC20 tokens or meet other necessary criteria.

8. **Protocol Fee Management**:
   - The protocol fee calculation and payment mechanism could be exploited if not properly audited, especially if the fee structure changes or if there are discrepancies in fee calculations.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using the Aave lending protocol. While it incorporates several best practices, such as using OpenZeppelin's libraries for access control and reentrancy protection, there are notable vulnerabilities that require attention.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract should ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Market Risks**: The reliance on external market conditions introduces slippage risks, which could lead to significant financial losses. Implementing more robust slippage protection mechanisms would enhance security.

3. **Access Control**: The access control mechanisms must be thoroughly audited to ensure that only authorized users can execute sensitive functions. This is critical for maintaining the integrity of the contract.

4. **Gas Efficiency**: The potential for gas limit issues should be addressed by optimizing loops and ensuring that the contract can handle a growing number of assets without failure.

5. **Error Handling**: Improving error messages and handling will aid in debugging and provide better feedback to users, enhancing the overall user experience.

6. **Front-Running Mitigation**: Strategies to mitigate front-running risks should be considered, such as implementing time-locks or using commit-reveal schemes for sensitive transactions.

7. **Input Validation**: Comprehensive input validation is necessary to prevent invalid data from being processed, which could lead to unexpected behavior or vulnerabilities.

8. **Fee Management**: A thorough review of the protocol fee structure and its implementation is essential to prevent exploitation and ensure accurate fee calculations.

In conclusion, while the `AaveLeverageModule` contract is built with several security features, it is essential to address the identified vulnerabilities to enhance its robustness and protect users' assets. A thorough audit and continuous monitoring of the contract's performance in a live environment are recommended to ensure ongoing security.

[2024-01-09 02:10:51 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `_executeTrade`, `_borrow`, `_repayBorrow`) that could potentially lead to reentrancy attacks if not properly managed. It is crucial to ensure that all state changes are made before any external calls.

2. **Slippage Risk**:
   - The `_executeTrade` function requires that the quantity of tokens received after a trade meets a minimum threshold. If the market experiences high volatility, there is a risk that the trade may not execute as expected, leading to potential losses.

3. **Access Control Issues**:
   - Functions that modify the state of the contract (e.g., `addCollateralAssets`, `removeCollateralAssets`, `lever`, `delever`) rely on the `onlyManagerAndValidSet` modifier. If this modifier is not robustly implemented, it could allow unauthorized users to execute sensitive functions.

4. **Gas Limit and Block Size Issues**:
   - The contract contains loops (e.g., in `sync` and asset management functions) that could consume significant gas if the number of assets grows large. This could lead to out-of-gas errors, preventing legitimate transactions from being processed.

5. **Improper Error Handling**:
   - The contract uses `require` statements for validation, but if any of these conditions fail, it may not provide sufficient context in the error messages. This could make debugging difficult for users.

6. **Potential for Front-Running**:
   - The contract's reliance on external price feeds and trading mechanisms could expose it to front-running attacks, where malicious actors exploit the timing of transactions to gain an advantage.

7. **Lack of Input Validation**:
   - Functions that accept external inputs (e.g., asset addresses) do not perform thorough validation to ensure that the inputs are valid ERC20 tokens or meet other necessary criteria.

8. **Protocol Fee Management**:
   - The protocol fee calculation and payment mechanism could be exploited if not properly audited, especially if the fee structure changes or if there are discrepancies in fee calculations.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using the Aave lending protocol. While it incorporates several best practices, such as using OpenZeppelin's libraries for access control and reentrancy protection, there are notable vulnerabilities that require attention.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive aspect; however, the contract should ensure that all state changes occur before any external calls to mitigate the risk of reentrancy attacks effectively.

2. **Market Risks**: The reliance on external market conditions introduces slippage risks, which could lead to significant financial losses. Implementing more robust slippage protection mechanisms would enhance security.

3. **Access Control**: The access control mechanisms must be thoroughly audited to ensure that only authorized users can execute sensitive functions. This is critical for maintaining the integrity of the contract.

4. **Gas Efficiency**: The potential for gas limit issues should be addressed by optimizing loops and ensuring that the contract can handle a growing number of assets without failure.

5. **Error Handling**: Improving error messages and handling will aid in debugging and provide better feedback to users, enhancing the overall user experience.

6. **Front-Running Mitigation**: Strategies to mitigate front-running risks should be considered, such as implementing time-locks or using commit-reveal schemes for sensitive transactions.

7. **Input Validation**: Comprehensive input validation is necessary to prevent invalid data from being processed, which could lead to unexpected behavior or vulnerabilities.

8. **Fee Management**: A thorough review of the protocol fee structure and its implementation is essential to prevent exploitation and ensure accurate fee calculations.

In conclusion, while the `AaveLeverageModule` contract is built with several security features, it is essential to address the identified vulnerabilities to enhance its robustness and protect users' assets. A thorough audit and continuous monitoring of the contract's performance in a live environment are recommended to ensure ongoing security.

[2024-01-09 02:10:51 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 02:10:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n\n    / ============ Events ============ */\n\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ */\n\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n\n        Different states of the SetToken and what this function does in those states:\n\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n\n        Values of variables in below if condition and corresponding action taken:\n\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:10:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:10:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24245
completion_tokens: 1
total_tokens: 24246
cost: $-1.000000


[2024-01-09 02:10:54 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

###

[2024-01-09 02:10:54 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:10:54 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 02:10:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:10:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:10:54 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:11:17 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:11:17 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12181
completion_tokens: 846
total_tokens: 13027
cost: $-1.000000


[2024-01-09 02:11:17 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Based on the provided smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - While the contract uses `ReentrancyGuard`, it is crucial to ensure that all external calls (especially those involving token transfers) are properly guarded. Any function that interacts with external contracts (like Aave) should be carefully analyzed to prevent reentrancy.

2. **Slippage Vulnerability**:
   - The `_executeTrade` function includes a slippage check, but if the slippage is too high, it reverts the transaction. This could lead to a denial of service if the market conditions change rapidly. A more robust mechanism to handle slippage might be necessary.

3. **Access Control Issues**:
   - Functions that modify state variables (like `addCollateralAssets`, `removeCollateralAssets`, etc.) are restricted to the manager. However, if the manager's address is compromised, it could lead to unauthorized changes. Implementing a multi-signature wallet for critical operations could enhance security.

4. **Protocol Fee Handling**:
   - The protocol fee is accrued and paid from the SetToken. If the fee calculation or payment process has flaws, it could lead to unexpected losses for users. Ensure that the fee calculation is transparent and verifiable.

5. **Asset Management Risks**:
   - The contract allows adding and removing collateral and borrow assets. If not properly validated, this could lead to situations where an asset is added that is not suitable for collateral or borrowing, potentially leading to liquidation risks.

6. **Gas Limit Issues**:
   - Functions that loop through arrays (like `sync` and asset management functions) could run into gas limit issues if the number of assets becomes large. This could lead to failed transactions.

7. **Lack of Event Emissions**:
   - While there are several events emitted for state changes, ensure that all critical state changes are logged. This is important for transparency and tracking.

8. **Potential for Front-Running**:
   - The contract interacts with external exchanges for trading. If not properly handled, it could be susceptible to front-running attacks where an attacker could exploit the timing of transactions.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using Aave as a lending protocol. While the contract implements several best practices, including the use of OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all external calls are adequately protected. A thorough review of all external interactions is necessary to prevent reentrancy attacks.

2. **Slippage Management**: The current mechanism for handling slippage could lead to denial of service under volatile market conditions. A more flexible approach to slippage management should be considered.

3. **Access Control**: The reliance on a single manager for critical operations poses a risk. Implementing multi-signature wallets or time-lock mechanisms could enhance security.

4. **Protocol Fee Transparency**: The fee structure should be clearly documented and verifiable to prevent unexpected losses for users.

5. **Asset Management**: The ability to add and remove assets must be tightly controlled and validated to avoid risks associated with unsuitable collateral or borrow assets.

6. **Gas Limit Considerations**: Functions that iterate over potentially large arrays should be optimized to avoid gas limit issues, which could lead to transaction failures.

7. **Event Emissions**: Ensure that all critical state changes are logged through events for better tracking and transparency.

8. **Front-Running Risks**: The design must consider potential front-running scenarios, especially in trading functions, to protect users from exploitative behaviors.

In conclusion, while the `AaveLeverageModule` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 02:11:17 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - While the contract uses `ReentrancyGuard`, it is crucial to ensure that all external calls (especially those involving token transfers) are properly guarded. Any function that interacts with external contracts (like Aave) should be carefully analyzed to prevent reentrancy.

2. **Slippage Vulnerability**:
   - The `_executeTrade` function includes a slippage check, but if the slippage is too high, it reverts the transaction. This could lead to a denial of service if the market conditions change rapidly. A more robust mechanism to handle slippage might be necessary.

3. **Access Control Issues**:
   - Functions that modify state variables (like `addCollateralAssets`, `removeCollateralAssets`, etc.) are restricted to the manager. However, if the manager's address is compromised, it could lead to unauthorized changes. Implementing a multi-signature wallet for critical operations could enhance security.

4. **Protocol Fee Handling**:
   - The protocol fee is accrued and paid from the SetToken. If the fee calculation or payment process has flaws, it could lead to unexpected losses for users. Ensure that the fee calculation is transparent and verifiable.

5. **Asset Management Risks**:
   - The contract allows adding and removing collateral and borrow assets. If not properly validated, this could lead to situations where an asset is added that is not suitable for collateral or borrowing, potentially leading to liquidation risks.

6. **Gas Limit Issues**:
   - Functions that loop through arrays (like `sync` and asset management functions) could run into gas limit issues if the number of assets becomes large. This could lead to failed transactions.

7. **Lack of Event Emissions**:
   - While there are several events emitted for state changes, ensure that all critical state changes are logged. This is important for transparency and tracking.

8. **Potential for Front-Running**:
   - The contract interacts with external exchanges for trading. If not properly handled, it could be susceptible to front-running attacks where an attacker could exploit the timing of transactions.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using Aave as a lending protocol. While the contract implements several best practices, including the use of OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all external calls are adequately protected. A thorough review of all external interactions is necessary to prevent reentrancy attacks.

2. **Slippage Management**: The current mechanism for handling slippage could lead to denial of service under volatile market conditions. A more flexible approach to slippage management should be considered.

3. **Access Control**: The reliance on a single manager for critical operations poses a risk. Implementing multi-signature wallets or time-lock mechanisms could enhance security.

4. **Protocol Fee Transparency**: The fee structure should be clearly documented and verifiable to prevent unexpected losses for users.

5. **Asset Management**: The ability to add and remove assets must be tightly controlled and validated to avoid risks associated with unsuitable collateral or borrow assets.

6. **Gas Limit Considerations**: Functions that iterate over potentially large arrays should be optimized to avoid gas limit issues, which could lead to transaction failures.

7. **Event Emissions**: Ensure that all critical state changes are logged through events for better tracking and transparency.

8. **Front-Running Risks**: The design must consider potential front-running scenarios, especially in trading functions, to protect users from exploitative behaviors.

In conclusion, while the `AaveLeverageModule` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-01-09 02:11:17 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 02:11:17 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n\n    / ============ Events ============ */\n\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ */\n\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n\n        Different states of the SetToken and what this function does in those states:\n\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n\n        Values of variables in below if condition and corresponding action taken:\n\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:11:17 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:11:17 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 02:11:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:11:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24245
completion_tokens: 1
total_tokens: 24246
cost: $-1.000000


[2024-01-09 02:11:20 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

###

[2024-01-09 02:11:20 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 02:11:20 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 02:11:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 02:11:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:11:20 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 02:11:33 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 02:11:33 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 12181
completion_tokens: 872
total_tokens: 13053
cost: $-1.000000


[2024-01-09 02:11:33 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Based on the provided smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, it is crucial to ensure that all external calls (like those to Aave or exchange adapters) are properly guarded. Any function that modifies state before calling an external contract could still be susceptible to reentrancy attacks if not handled correctly.

2. **Slippage Risk**:
   - The `_executeTrade` function includes a check for slippage, but if the price changes significantly during the trade execution, it could lead to unexpected losses. The minimum receive quantity should be carefully calculated to mitigate this risk.

3. **Access Control Issues**:
   - The contract relies on the `onlyManagerAndValidSet` modifier for critical functions like `lever` and `delever`. If the manager's address is compromised, it could lead to unauthorized access. Proper governance mechanisms should be in place to manage the manager's permissions.

4. **Gas Limit and Block Size Issues**:
   - The contract performs multiple operations in loops (e.g., syncing positions). If the number of collateral or borrow assets is large, this could lead to exceeding gas limits, causing transactions to fail. Implementing pagination or batching could help mitigate this.

5. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the total exchanged quantity. If the fee structure changes or is not well-defined, it could lead to unexpected fees being charged, impacting the profitability of trades.

6. **Potential for Liquidation**:
   - The contract allows for leverage trading, which inherently carries the risk of liquidation if the collateral value decreases significantly. Proper risk management strategies should be implemented to monitor and mitigate this risk.

7. **Lack of Input Validation**:
   - Functions that accept external input (like asset addresses) should include checks to ensure that the inputs are valid and correspond to actual ERC20 tokens. This can prevent issues related to invalid or malicious inputs.

8. **Event Emission**:
   - While events are emitted for significant actions, it is essential to ensure that all critical state changes are logged. This helps in tracking and auditing the contract's behavior.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using Aave's lending protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all external calls are properly guarded to prevent reentrancy attacks.

2. **Slippage and Trade Execution**: The contract should implement more robust mechanisms to handle slippage and ensure that trades are executed at expected prices. This could involve more sophisticated price oracles or slippage tolerance settings.

3. **Access Control**: The reliance on a single manager for critical operations poses a risk. A multi-signature wallet or a governance mechanism could enhance security by distributing control.

4. **Gas Limit Management**: The potential for exceeding gas limits during operations should be addressed through efficient coding practices, such as avoiding loops with unbounded iterations.

5. **Fee Structure Clarity**: Clear documentation and implementation of the fee structure are essential to avoid unexpected charges that could deter users.

6. **Risk Management**: Given the nature of leverage trading, implementing risk management strategies to monitor collateral values and prevent liquidation is crucial.

7. **Input Validation**: Ensuring that all inputs are validated will help prevent issues related to invalid token addresses or unexpected behavior.

8. **Event Logging**: Comprehensive event logging for all state changes will aid in auditing and tracking the contract's operations.

In conclusion, while the `AaveLeverageModule` contract is a sophisticated implementation for leveraging assets on Aave, it requires careful attention to security vulnerabilities. Addressing the identified issues will enhance the contract's robustness and reliability, ultimately protecting users and their assets. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats and best practices.

[2024-01-09 02:11:33 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `AaveLeverageModule`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, it is crucial to ensure that all external calls (like those to Aave or exchange adapters) are properly guarded. Any function that modifies state before calling an external contract could still be susceptible to reentrancy attacks if not handled correctly.

2. **Slippage Risk**:
   - The `_executeTrade` function includes a check for slippage, but if the price changes significantly during the trade execution, it could lead to unexpected losses. The minimum receive quantity should be carefully calculated to mitigate this risk.

3. **Access Control Issues**:
   - The contract relies on the `onlyManagerAndValidSet` modifier for critical functions like `lever` and `delever`. If the manager's address is compromised, it could lead to unauthorized access. Proper governance mechanisms should be in place to manage the manager's permissions.

4. **Gas Limit and Block Size Issues**:
   - The contract performs multiple operations in loops (e.g., syncing positions). If the number of collateral or borrow assets is large, this could lead to exceeding gas limits, causing transactions to fail. Implementing pagination or batching could help mitigate this.

5. **Protocol Fee Calculation**:
   - The protocol fee is calculated based on the total exchanged quantity. If the fee structure changes or is not well-defined, it could lead to unexpected fees being charged, impacting the profitability of trades.

6. **Potential for Liquidation**:
   - The contract allows for leverage trading, which inherently carries the risk of liquidation if the collateral value decreases significantly. Proper risk management strategies should be implemented to monitor and mitigate this risk.

7. **Lack of Input Validation**:
   - Functions that accept external input (like asset addresses) should include checks to ensure that the inputs are valid and correspond to actual ERC20 tokens. This can prevent issues related to invalid or malicious inputs.

8. **Event Emission**:
   - While events are emitted for significant actions, it is essential to ensure that all critical state changes are logged. This helps in tracking and auditing the contract's behavior.

### Comprehensive Analysis Report

The `AaveLeverageModule` contract is designed to facilitate leverage trading using Aave's lending protocol. While it incorporates several best practices, including the use of OpenZeppelin's libraries for access control and reentrancy protection, there are notable security vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all external calls are properly guarded to prevent reentrancy attacks.

2. **Slippage and Trade Execution**: The contract should implement more robust mechanisms to handle slippage and ensure that trades are executed at expected prices. This could involve more sophisticated price oracles or slippage tolerance settings.

3. **Access Control**: The reliance on a single manager for critical operations poses a risk. A multi-signature wallet or a governance mechanism could enhance security by distributing control.

4. **Gas Limit Management**: The potential for exceeding gas limits during operations should be addressed through efficient coding practices, such as avoiding loops with unbounded iterations.

5. **Fee Structure Clarity**: Clear documentation and implementation of the fee structure are essential to avoid unexpected charges that could deter users.

6. **Risk Management**: Given the nature of leverage trading, implementing risk management strategies to monitor collateral values and prevent liquidation is crucial.

7. **Input Validation**: Ensuring that all inputs are validated will help prevent issues related to invalid token addresses or unexpected behavior.

8. **Event Logging**: Comprehensive event logging for all state changes will aid in auditing and tracking the contract's operations.

In conclusion, while the `AaveLeverageModule` contract is a sophisticated implementation for leveraging assets on Aave, it requires careful attention to security vulnerabilities. Addressing the identified issues will enhance the contract's robustness and reliability, ultimately protecting users and their assets. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats and best practices.

[2024-01-09 02:11:36 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '/\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n/\n\npragma solidity 0.6.10;\npragma experimental "ABIEncoderV2";\n\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";\nimport { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport { AaveV2 } from "../../integration/lib/AaveV2.sol";\nimport { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";\nimport { IController } from "../../../interfaces/IController.sol";\nimport { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";\nimport { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";\nimport { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";\nimport { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";\nimport { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";\nimport { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";\nimport { ISetToken } from "../../../interfaces/ISetToken.sol";\nimport { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";\nimport { ModuleBase } from "../../lib/ModuleBase.sol";\n\n/\n * @title AaveLeverageModule\n * @author Set Protocol\n * @notice Smart contract that enables leverage trading using Aave as the lending protocol.\n * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of\n * debt when borrowed assets are the same.\n /\ncontract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using AaveV2 for ISetToken;\n\n    / ============ Structs ============ /\n\n    struct EnabledAssets {\n        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken\n        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken\n    }\n\n    struct ActionInfo {\n        ISetToken setToken;                      // SetToken instance\n        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it\'s best practice not to store\n        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance\n        uint256 setTotalSupply;                  // Total supply of SetToken\n        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange\n        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange\n        IERC20 collateralAsset;                  // Address of collateral asset\n        IERC20 borrowAsset;                      // Address of borrow asset\n        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance\n    }\n\n    struct ReserveTokens {\n        IAToken aToken;                         // Reserve\'s aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve\'s variable debt token instance\n    }\n\n    / ============ Events ============ */\n\n    /\n     * @dev Emitted on lever()\n     * @param _setToken             Instance of the SetToken being levered\n     * @param _borrowAsset          Asset being borrowed for leverage\n     * @param _collateralAsset      Collateral asset being levered\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalBorrowAmount    Total amount of _borrowAsset borrowed\n     * @param _totalReceiveAmount   Total amount of _collateralAsset received by selling _borrowAsset\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageIncreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _borrowAsset,\n        IERC20 indexed _collateralAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalBorrowAmount,\n        uint256 _totalReceiveAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on delever() and deleverToZeroBorrowBalance()\n     * @param _setToken             Instance of the SetToken being delevered\n     * @param _collateralAsset      Asset sold to decrease leverage\n     * @param _repayAsset           Asset being bought to repay to Aave\n     * @param _exchangeAdapter      Exchange adapter used for trading\n     * @param _totalRedeemAmount    Total amount of _collateralAsset being sold\n     * @param _totalRepayAmount     Total amount of _repayAsset being repaid\n     * @param _protocolFee          Protocol fee charged\n     /\n    event LeverageDecreased(\n        ISetToken indexed _setToken,\n        IERC20 indexed _collateralAsset,\n        IERC20 indexed _repayAsset,\n        IExchangeAdapter _exchangeAdapter,\n        uint256 _totalRedeemAmount,\n        uint256 _totalRepayAmount,\n        uint256 _protocolFee\n    );\n\n    /\n     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()\n     * @param _setToken Instance of SetToken whose collateral assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of collateral assets being added/removed\n     */\n    event CollateralAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()\n     * @param _setToken Instance of SetToken whose borrow assets is updated\n     * @param _added    true if assets are added false if removed\n     * @param _assets   Array of borrow assets being added/removed\n     /\n    event BorrowAssetsUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added,\n        IERC20[] _assets\n    );\n\n    /\n     * @dev Emitted when underlyingToReserveTokensMappings is updated\n     * @param _underlying           Address of the underlying asset\n     * @param _aToken               Updated aave reserve aToken\n     * @param _variableDebtToken    Updated aave reserve variable debt token\n     /\n    event ReserveTokensUpdated(\n        IERC20 indexed _underlying,\n        IAToken indexed _aToken,\n        IVariableDebtToken indexed _variableDebtToken\n    );\n\n    /\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     /\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    / ============ Constants ============ /\n\n    // This module only supports borrowing in variable rate mode from Aave which is represented by 2\n    uint256 constant internal BORROW_RATE_MODE = 2;\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";\n\n    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function\n    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\n\n    / ============ State Variables ============ /\n\n    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them\n    // upon requirement is more efficient than fetching them each time from Aave.\n    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.\n    mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;\n\n    // Used to fetch reserves and user data from AaveV2\n    IProtocolDataProvider public immutable protocolDataProvider;\n\n    // Used to fetch lendingPool address. This contract is immutable and its address will never change.\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;\n\n    // Mapping to efficiently check if collateral asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;\n\n    // Mapping to efficiently check if a borrow asset is enabled in SetToken\n    mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;\n\n    // Internal mapping of enabled collateral and borrow tokens for syncing positions\n    mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken =&gt; bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    / ============ Constructor ============ /\n\n    /\n     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.\n     * @param _controller                       Address of controller contract\n     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider\n     /\n    constructor(\n        IController _controller,\n        ILendingPoolAddressesProvider _lendingPoolAddressesProvider\n    )\n        public\n        ModuleBase(_controller)\n    {\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(\n            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.\n            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)\n        );\n        protocolDataProvider = _protocolDataProvider;\n\n        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i &lt; reserveTokens.length; i++) {\n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));\n        }\n    }\n\n    / ============ External Functions ============ /\n\n    /\n     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.\n     * Deposits _collateralAsset to Aave and mints corresponding aToken.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                     Instance of the SetToken\n     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage\n     * @param _collateralAsset              Address of underlying collateral asset\n     * @param _borrowQuantityUnits          Borrow quantity of asset in position units\n     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units\n     * @param _tradeAdapterName             Name of trade adapter\n     * @param _tradeData                    Arbitrary data for trade\n     */\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n\n    /\n     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Repays _repayAsset to Aave and burns corresponding debt tokens.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * @param _setToken                 Instance of the SetToken\n     * @param _collateralAsset          Address of underlying collateral asset being withdrawn\n     * @param _repayAsset               Address of underlying borrowed asset being repaid\n     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units\n     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units\n     * @param _tradeAdapterName         Name of trade adapter\n     * @param _tradeData                Arbitrary data for trade\n     /\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from\n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }\n\n    / @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.\n     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.\n     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.\n     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .\n     * updated as equity. No protocol fee is charged.\n     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.\n     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAsset      Address of underlying collateral asset being redeemed\n     * @param _repayAsset           Address of underlying asset being repaid\n     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units\n     * @param _tradeAdapterName     Name of trade adapter\n     * @param _tradeData            Arbitrary data for trade\n     * @return uint256              Notional repay quantity\n     /\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.\n     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.\n     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated\n     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid\n     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of\n     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.\n     * @param _setToken               Instance of the SetToken\n     */\n    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 setTotalSupply = _setToken.totalSupply();\n\n        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the\n        // first issuance, then editDefaultPosition would remove the default positions from the SetToken\n        if (setTotalSupply &gt; 0) {\n            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;\n\n                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();\n                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (previousPositionUnit != newPositionUnit) {\n                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);\n                }\n            }\n\n            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n                IERC20 borrowAsset = IERC20(borrowAssets[i]);\n\n                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));\n                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);\n\n                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets\n                if (newPositionUnit != previousPositionUnit) {\n                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);\n                }\n            }\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list\n     * or anySetAllowed needs to be true. Only callable by the SetToken\'s manager.\n     * Note: Managers can enable collateral and borrow assets that don\'t exist as positions on the SetToken\n     * @param _setToken             Instance of the SetToken to initialize\n     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken\n     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken\n     /\n    function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], "Not allowed SetToken");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets\n     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.\n     * Note: Function will revert is there is any debt remaining on Aave\n     /\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Sync Aave and SetToken positions prior to any removal action\n        sync(setToken);\n\n        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;\n        for(uint256 i = 0; i &lt; borrowAssets.length; i++) {\n            IERC20 borrowAsset = IERC20(borrowAssets[i]);\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[setToken][borrowAsset];\n        }\n\n        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;\n        for(uint256 i = 0; i &lt; collateralAssets.length; i++) {\n            IERC20 collateralAsset = IERC20(collateralAssets[i]);\n            _updateUseReserveAsCollateral(setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[setToken][collateralAsset];\n        }\n\n        delete enabledAssets[setToken];\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i &lt; modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n        }\n    }\n\n    /\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /\n     * @dev CALLABLE BY ANYBODY: Updates underlyingToReserveTokens mappings. Reverts if mapping already exists\n     * or the passed _underlying asset does not have a valid reserve on Aave.\n     * Note: Call this function when Aave adds a new reserve.\n     * @param _underlying               Address of underlying asset\n     /\n    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {\n        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));\n        require(isActive, "Invalid aave reserve");\n\n        _addUnderlyingToReserveTokensMapping(_underlying);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.\n     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.\n     \n     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER\'S EXPLICIT PERMISSION.\n     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.\n     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.\n     \n     * @param _setToken             Instance of the SetToken\n     * @param _newCollateralAssets  Addresses of new collateral underlying assets\n     /\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     /\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     /\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     /\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleIssueHook(ISetToken _setToken, uint256 / _setTokenQuantity /) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed\n     * balance after interest accrual. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     /\n    function moduleRedeemHook(ISetToken _setToken, uint256 / _setTokenQuantity */) external override onlyModule(_setToken) {\n        sync(_setToken);\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for\n     * module to return debt to issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    /\n     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after\n     * the issuance module transfers debt from the issuer. Only callable by valid module.\n     * @param _setToken             Instance of the SetToken\n     * @param _setTokenQuantity     Quantity of SetToken\n     * @param _component            Address of component\n     /\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt &lt; 0, "Component must be negative");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    / ============ External Getter Functions ============ /\n\n    /\n     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.\n     * @return Underlying collateral assets that are enabled\n     * @return Underlying borrowed assets that are enabled\n     /\n    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {\n        return (\n            enabledAssets[_setToken].collateralAssets,\n            enabledAssets[_setToken].borrowAssets\n        );\n    }\n\n    / ============ Internal Functions ============ */\n\n    /\n     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.\n     /\n    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.\n     /\n    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n     */\n    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     /\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.\n     /\n    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    /\n     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the\n     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.\n     */\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);\n    }\n\n    /\n     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken\n     * @return uint256     The quantity of tokens received post-trade\n     /\n    function _executeTrade(\n        ActionInfo memory _actionInfo,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        bytes memory _data\n    )\n        internal\n        returns (uint256)\n    {\n        ISetToken setToken = _actionInfo.setToken;\n        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;\n\n        setToken.invokeApprove(\n            address(_sendToken),\n            _actionInfo.exchangeAdapter.getSpender(),\n            notionalSendQuantity\n        );\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n\n        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);\n        require(\n            receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,\n            "Slippage too high"\n        );\n\n        return receiveTokenQuantity;\n    }\n\n    /\n     * @dev Calculates protocol fee on module and pays protocol fee from SetToken\n     * @return uint256          Total protocol fee paid\n     /\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n\n    /\n     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken\n     */\n    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {\n        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;\n        _updateCollateralPosition(\n            _actionInfo.setToken,\n            aToken,\n            _getCollateralPosition(\n                _actionInfo.setToken,\n                aToken,\n                _actionInfo.setTotalSupply\n            )\n        );\n\n        _updateBorrowPosition(\n            _actionInfo.setToken,\n            _borrowAsset,\n            _getBorrowPosition(\n                _actionInfo.setToken,\n                _borrowAsset,\n                _actionInfo.setTotalSupply\n            )\n        );\n    }\n\n    /\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     /\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n\n    /\n     * @dev Updates default position unit for given aToken on SetToken\n     /\n    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {\n        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);\n    }\n\n    /\n     * @dev Updates external position unit for given borrow asset on SetToken\n     */\n    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {\n        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply),\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n    /\n     * @dev Construct the ActionInfo struct for lever and delever accepting notional units\n     * @return ActionInfo       Instance of constructed ActionInfo struct\n     /\n    function _createAndValidateActionInfoNotional(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _notionalSendQuantity,\n        uint256 _minNotionalReceiveQuantity,\n        string memory _tradeAdapterName,\n        bool _isLever,\n        uint256 _setTotalSupply\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        ActionInfo memory actionInfo = ActionInfo ({\n            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),\n            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n            setToken: _setToken,\n            collateralAsset: _isLever ? _receiveToken : _sendToken,\n            borrowAsset: _isLever ? _sendToken : _receiveToken,\n            setTotalSupply: _setTotalSupply,\n            notionalSendQuantity: _notionalSendQuantity,\n            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,\n            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))\n        });\n\n        _validateCommon(actionInfo);\n\n        return actionInfo;\n    }\n\n    /\n     * @dev Updates underlyingToReserveTokens mappings for given _underlying asset. Emits ReserveTokensUpdated event.\n     */\n    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {\n        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));\n        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);\n        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);\n\n        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));\n    }\n\n    /\n     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.\n     * Emits CollateralAssetsUpdated event.\n     /\n    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {\n        for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {\n            IERC20 collateralAsset = _newCollateralAssets[i];\n\n            _validateNewCollateralAsset(_setToken, collateralAsset);\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);\n\n            collateralAssetEnabled[_setToken][collateralAsset] = true;\n            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);\n    }\n\n    /\n     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.\n     * Emits BorrowAssetsUpdated event.\n     /\n    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {\n        for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {\n            IERC20 borrowAsset = _newBorrowAssets[i];\n\n            _validateNewBorrowAsset(_setToken, borrowAsset);\n\n            borrowAssetEnabled[_setToken][borrowAsset] = true;\n            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);\n    }\n\n    /\n     * @dev Updates SetToken\'s ability to use an asset as collateral on Aave\n     /\n    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {\n        /\n        Note: Aave ENABLES an asset to be used as collateral by to address in an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. to address had zero aToken balance before the transfer\n            3. transfer amount is greater than 0\n\n        Note: Aave DISABLES an asset to be used as collateral by msg.senderin an aToken.transfer(to, amount) call provided\n            1. msg.sender (from address) isn\'t the same as to address\n            2. msg.sender has zero balance after the transfer\n\n        Different states of the SetToken and what this function does in those states:\n\n            Case 1: Manager adds collateral asset to SetToken before first issuance\n                - Since aToken.balanceOf(setToken) == 0, we do not call setToken.invokeUserUseReserveAsCollateral because Aave\n                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral\n                on Aave markets.\n\n            Case 2: First issuance of the SetToken\n                - SetToken was initialized with aToken as default position\n                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken\n                - Aave enables aToken to be used as collateral by the SetToken\n                - Manager calls lever() and the aToken is used as collateral to borrow other assets\n\n            Case 3: Manager removes collateral asset from the SetToken\n                - Disable asset to be used as collateral on SetToken by calling setToken.invokeSetUserUseReserveAsCollateral with\n                useAsCollateral equals false\n                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole\n                transaction reverts, and manager can\'t remove corresponding collateral asset\n\n            Case 4: Manager adds collateral asset after removing it\n                - If aToken.balanceOf(setToken) &gt; 0, we call setToken.invokeUserUseReserveAsCollateral and the corresponding aToken\n                is re-enabled as collateral on Aave\n\n            Case 5: On redemption/delever/liquidated and aToken balance becomes zero\n                - Aave disables aToken to be used as collateral by SetToken\n\n        Values of variables in below if condition and corresponding action taken:\n\n        ---------------------------------------------------------------------------------------------------------------------\n        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |\n        |                          |                   |                       |   collateral when aToken balance becomes 0 |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |\n        |--------------------------|-------------------|-----------------------|--------------------------------------------|\n        |   false                  |   true            |   = 0                 |   Don\'t invoke. Will revert.               |\n        ---------------------------------------------------------------------------------------------------------------------\n        */\n        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));\n        if (\n            usageAsCollateralEnabled != _useAsCollateral\n            &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0\n        ) {\n            _setToken.invokeSetUserUseReserveAsCollateral(\n                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),\n                address(_asset),\n                _useAsCollateral\n            );\n        }\n    }\n\n    /\n     * @dev Validate common requirements for lever and delever\n     /\n    function _validateCommon(ActionInfo memory _actionInfo) internal view {\n        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");\n        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");\n        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");\n        require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as collateral asset for given SetToken\n     /\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal underlyingToReserveTokens mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, "Invalid aave reserve");\n        // A frozen reserve doesn\'t allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, "Frozen aave reserve");\n        require(usageAsCollateralEnabled, "Collateral disabled on Aave");\n    }\n\n    /\n     * @dev Validates if a new asset can be added as borrow asset for given SetToken\n     */\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, "Invalid aave reserve");\n        require(!isFrozen, "Frozen aave reserve");\n        require(borrowingEnabled, "Borrowing disabled on Aave");\n    }\n\n    /\n     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken\n     \n     * @return uint256       default collateral position unit\n     /\n    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {\n        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));\n        return collateralNotionalBalance.preciseDiv(_setTotalSupply);\n    }\n\n    /\n     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken\n     \n     * @return int256       external borrow position unit\n     /\n    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {\n        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));\n        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 02:11:36 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | /*     Copyright 2021 Set Labs Inc. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.  SPDX-License-Identifier: Apache License, Version 2.0  */ pragma solidity 0.6.10; pragma experimental "ABIEncoderV2"; import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol"; import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import { AaveV2 } from "../../integration/lib/AaveV2.sol"; import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol"; import { IController } from "../../../interfaces/IController.sol"; import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol"; import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol"; import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol"; import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol"; import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol"; import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol"; import { ISetToken } from "../../../interfaces/ISetToken.sol"; import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol"; import { ModuleBase } from "../../lib/ModuleBase.sol"; /*  * @title AaveLeverageModule  * @author Set Protocol  * @notice Smart contract that enables leverage trading using Aave as the lending protocol.  * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of  * debt when borrowed assets are the same.  / contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {     using AaveV2 for ISetToken; /* ============ Structs ============ */  struct EnabledAssets {     address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken     address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken }  struct ActionInfo {     ISetToken setToken;                      // SetToken instance     ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store     IExchangeAdapter exchangeAdapter;        // Exchange adapter instance     uint256 setTotalSupply;                  // Total supply of SetToken     uint256 notionalSendQuantity;            // Total notional quantity sent to exchange     uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange     IERC20 collateralAsset;                  // Address of collateral asset     IERC20 borrowAsset;                      // Address of borrow asset     uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance }  struct ReserveTokens {     IAToken aToken;                         // Reserve's aToken instance     IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance }  /* ============ Events ============ */  /**  * @dev Emitted on lever()  * @param _setToken             Instance of the SetToken being levered  * @param _borrowAsset          Asset being borrowed for leverage  * @param _collateralAsset      Collateral asset being levered  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed  * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`  * @param _protocolFee          Protocol fee charged  */ event LeverageIncreased(     ISetToken indexed _setToken,     IERC20 indexed _borrowAsset,     IERC20 indexed _collateralAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalBorrowAmount,     uint256 _totalReceiveAmount,     uint256 _protocolFee );  /**  * @dev Emitted on delever() and deleverToZeroBorrowBalance()  * @param _setToken             Instance of the SetToken being delevered  * @param _collateralAsset      Asset sold to decrease leverage  * @param _repayAsset           Asset being bought to repay to Aave  * @param _exchangeAdapter      Exchange adapter used for trading  * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold  * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid  * @param _protocolFee          Protocol fee charged  */ event LeverageDecreased(     ISetToken indexed _setToken,     IERC20 indexed _collateralAsset,     IERC20 indexed _repayAsset,     IExchangeAdapter _exchangeAdapter,     uint256 _totalRedeemAmount,     uint256 _totalRepayAmount,     uint256 _protocolFee );  /**  * @dev Emitted on addCollateralAssets() and removeCollateralAssets()  * @param _setToken Instance of SetToken whose collateral assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of collateral assets being added/removed  */ event CollateralAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted on addBorrowAssets() and removeBorrowAssets()  * @param _setToken Instance of SetToken whose borrow assets is updated  * @param _added    true if assets are added false if removed  * @param _assets   Array of borrow assets being added/removed  */ event BorrowAssetsUpdated(     ISetToken indexed _setToken,     bool indexed _added,     IERC20[] _assets );  /**  * @dev Emitted when `underlyingToReserveTokensMappings` is updated  * @param _underlying           Address of the underlying asset  * @param _aToken               Updated aave reserve aToken  * @param _variableDebtToken    Updated aave reserve variable debt token  */ event ReserveTokensUpdated(     IERC20 indexed _underlying,     IAToken indexed _aToken,     IVariableDebtToken indexed _variableDebtToken );  /**  * @dev Emitted on updateAllowedSetToken()  * @param _setToken SetToken being whose allowance to initialize this module is being updated  * @param _added    true if added false if removed  */ event SetTokenStatusUpdated(     ISetToken indexed _setToken,     bool indexed _added );  /**  * @dev Emitted on updateAnySetAllowed()  * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise  */ event AnySetAllowedUpdated(     bool indexed _anySetAllowed );  /* ============ Constants ============ */  // This module only supports borrowing in variable rate mode from Aave which is represented by 2 uint256 constant internal BORROW_RATE_MODE = 2;  // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as // the string as the integration name string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";  // 0 index stores protocol fee % on the controller, charged in the _executeTrade function uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;  /* ============ State Variables ============ */  // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them // upon requirement is more efficient than fetching them each time from Aave. // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first. mapping(IERC20 =&gt; ReserveTokens) public underlyingToReserveTokens;  // Used to fetch reserves and user data from AaveV2 IProtocolDataProvider public immutable protocolDataProvider;  // Used to fetch lendingPool address. This contract is immutable and its address will never change. ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;  // Mapping to efficiently check if collateral asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public collateralAssetEnabled;  // Mapping to efficiently check if a borrow asset is enabled in SetToken mapping(ISetToken =&gt; mapping(IERC20 =&gt; bool)) public borrowAssetEnabled;  // Internal mapping of enabled collateral and borrow tokens for syncing positions mapping(ISetToken =&gt; EnabledAssets) internal enabledAssets;  // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance mapping(ISetToken =&gt; bool) public allowedSetTokens;  // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance. bool public anySetAllowed;  /* ============ Constructor ============ */  /**  * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.  * @param _controller                       Address of controller contract  * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider  */ constructor(     IController _controller,     ILendingPoolAddressesProvider _lendingPoolAddressesProvider )     public     ModuleBase(_controller) {     lendingPoolAddressesProvider = _lendingPoolAddressesProvider;     IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(         // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.         _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)     );     protocolDataProvider = _protocolDataProvider;      IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();     for(uint256 i = 0; i &lt; reserveTokens.length; i++) {         (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);         underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));     } }  /* ============ External Functions ============ */  /**  * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.  * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.  * Deposits _collateralAsset to Aave and mints corresponding aToken.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                     Instance of the SetToken  * @param _borrowAsset                  Address of underlying asset being borrowed for leverage  * @param _collateralAsset              Address of underlying collateral asset  * @param _borrowQuantityUnits          Borrow quantity of asset in position units  * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units  * @param _tradeAdapterName             Name of trade adapter  * @param _tradeData                    Arbitrary data for trade  */ function lever(     ISetToken _setToken,     IERC20 _borrowAsset,     IERC20 _collateralAsset,     uint256 _borrowQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // For levering up, send quantity is derived from borrow asset and receive quantity is derived from     // collateral asset     ActionInfo memory leverInfo = _createAndValidateActionInfo(         _setToken,         _borrowAsset,         _collateralAsset,         _borrowQuantityUnits,         _minReceiveQuantityUnits,         _tradeAdapterName,         true     );      _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);      uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);      _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);      _updateLeverPositions(leverInfo, _borrowAsset);      emit LeverageIncreased(         _setToken,         _borrowAsset,         _collateralAsset,         leverInfo.exchangeAdapter,         leverInfo.notionalSendQuantity,         postTradeCollateralQuantity,         protocolFee     ); }  /**  * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Repays _repayAsset to Aave and burns corresponding debt tokens.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * @param _setToken                 Instance of the SetToken  * @param _collateralAsset          Address of underlying collateral asset being withdrawn  * @param _repayAsset               Address of underlying borrowed asset being repaid  * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units  * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units  * @param _tradeAdapterName         Name of trade adapter  * @param _tradeData                Arbitrary data for trade  */ function delever(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     uint256 _minRepayQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken) {     // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from     // repay asset     ActionInfo memory deleverInfo = _createAndValidateActionInfo(         _setToken,         _collateralAsset,         _repayAsset,         _redeemQuantityUnits,         _minRepayQuantityUnits,         _tradeAdapterName,         false     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);      uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         repayQuantity,         protocolFee     ); }  /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.  * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.  * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.  * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .  * updated as equity. No protocol fee is charged.  * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.  * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.  * @param _setToken             Instance of the SetToken  * @param _collateralAsset      Address of underlying collateral asset being redeemed  * @param _repayAsset           Address of underlying asset being repaid  * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units  * @param _tradeAdapterName     Name of trade adapter  * @param _tradeData            Arbitrary data for trade  * @return uint256              Notional repay quantity  */ function deleverToZeroBorrowBalance(     ISetToken _setToken,     IERC20 _collateralAsset,     IERC20 _repayAsset,     uint256 _redeemQuantityUnits,     string memory _tradeAdapterName,     bytes memory _tradeData )     external     nonReentrant     onlyManagerAndValidSet(_setToken)     returns (uint256) {     uint256 setTotalSupply = _setToken.totalSupply();     uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);      require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");     uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));     require(notionalRepayQuantity &gt; 0, "Borrow balance is zero");      ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(         _setToken,         _collateralAsset,         _repayAsset,         notionalRedeemQuantity,         notionalRepayQuantity,         _tradeAdapterName,         false,         setTotalSupply     );      _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);      _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);      _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);      _updateDeleverPositions(deleverInfo, _repayAsset);      emit LeverageDecreased(         _setToken,         _collateralAsset,         _repayAsset,         deleverInfo.exchangeAdapter,         deleverInfo.notionalSendQuantity,         notionalRepayQuantity,         0   // No protocol fee     );      return notionalRepayQuantity; }  /**  * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.  * For collateral assets, update aToken default position. For borrow assets, update external borrow position.  * - Collateral assets may come out of sync when interest is accrued or a position is liquidated  * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid  * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of  * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.  * @param _setToken               Instance of the SetToken  */ function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {     uint256 setTotalSupply = _setToken.totalSupply();      // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the     // first issuance, then editDefaultPosition would remove the default positions from the SetToken     if (setTotalSupply &gt; 0) {         address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;         for(uint256 i = 0; i &lt; collateralAssets.length; i++) {             IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;              uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();             uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (previousPositionUnit != newPositionUnit) {               _updateCollateralPosition(_setToken, aToken, newPositionUnit);             }         }          address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;         for(uint256 i = 0; i &lt; borrowAssets.length; i++) {             IERC20 borrowAsset = IERC20(borrowAssets[i]);              int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));             int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);              // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets             if (newPositionUnit != previousPositionUnit) {                 _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);             }         }     } }  /**  * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list  * or anySetAllowed needs to be true. Only callable by the SetToken's manager.  * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken  * @param _setToken             Instance of the SetToken to initialize  * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken  * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken  */ function initialize(     ISetToken _setToken,     IERC20[] memory _collateralAssets,     IERC20[] memory _borrowAssets )     external     onlySetManager(_setToken, msg.sender)     onlyValidAndPendingSet(_setToken) {     if (!anySetAllowed) {         require(allowedSetTokens[_setToken], "Not allowed SetToken");     }      // Initialize module before trying register     _setToken.initializeModule();      // Get debt issuance module registered to this module and require that it is initialized     require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");      // Try if register exists on any of the modules including the debt issuance module     address[] memory modules = _setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}     }      // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions     _addCollateralAssets(_setToken, _collateralAssets);     _addBorrowAssets(_setToken, _borrowAssets); }  /**  * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets  * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.  * Note: Function will revert is there is any debt remaining on Aave  */ function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {     ISetToken setToken = ISetToken(msg.sender);      // Sync Aave and SetToken positions prior to any removal action     sync(setToken);      address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;     for(uint256 i = 0; i &lt; borrowAssets.length; i++) {         IERC20 borrowAsset = IERC20(borrowAssets[i]);         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[setToken][borrowAsset];     }      address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;     for(uint256 i = 0; i &lt; collateralAssets.length; i++) {         IERC20 collateralAsset = IERC20(collateralAssets[i]);         _updateUseReserveAsCollateral(setToken, collateralAsset, false);          delete collateralAssetEnabled[setToken][collateralAsset];     }      delete enabledAssets[setToken];      // Try if unregister exists on any of the modules     address[] memory modules = setToken.getModules();     for(uint256 i = 0; i &lt; modules.length; i++) {         try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}     } }  /**  * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.  * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function  * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies  * @param _setToken             Instance of the SetToken  * @param _debtIssuanceModule   Debt issuance module address to register  */ function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {     require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");      _debtIssuanceModule.registerToIssuanceModule(_setToken); }  /**  * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists  * or the passed _underlying asset does not have a valid reserve on Aave.  * Note: Call this function when Aave adds a new reserve.  * @param _underlying               Address of underlying asset  */ function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {     require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");      // An active reserve is an alias for a valid reserve on Aave.     (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));     require(isActive, "Invalid aave reserve");      _addUnderlyingToReserveTokensMapping(_underlying); }  /**  * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.  * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.  *  * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.  * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.  * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.  *  * @param _setToken             Instance of the SetToken  * @param _newCollateralAssets  Addresses of new collateral underlying assets  */ function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {     _addCollateralAssets(_setToken, _newCollateralAssets); }  /**  * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.  * @param _setToken             Instance of the SetToken  * @param _collateralAssets     Addresses of collateral underlying assets to remove  */ function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _collateralAssets.length; i++) {         IERC20 collateralAsset = _collateralAssets[i];         require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");          _updateUseReserveAsCollateral(_setToken, collateralAsset, false);          delete collateralAssetEnabled[_setToken][collateralAsset];         enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, false, _collateralAssets); }  /**  * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.  * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.  * @param _setToken             Instance of the SetToken  * @param _newBorrowAssets      Addresses of borrow underlying assets to add  */ function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {     _addBorrowAssets(_setToken, _newBorrowAssets); }  /**  * @dev MANAGER ONLY: Remove borrow assets.  * Note: If there is a borrow balance, borrow asset cannot be removed  * @param _setToken             Instance of the SetToken  * @param _borrowAssets         Addresses of borrow underlying assets to remove  */ function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {      for(uint256 i = 0; i &lt; _borrowAssets.length; i++) {         IERC20 borrowAsset = _borrowAssets[i];          require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");         require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");          delete borrowAssetEnabled[_setToken][borrowAsset];         enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, false, _borrowAssets); }  /**  * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.  * @param _setToken             Instance of the SetToken  * @param _status               Bool indicating if _setToken is allowed to initialize this module  */ function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {     require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");     allowedSetTokens[_setToken] = _status;     emit SetTokenStatusUpdated(_setToken, _status); }  /**  * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.  * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module  */ function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {     anySetAllowed = _anySetAllowed;     emit AnySetAllowedUpdated(_anySetAllowed); }  /**  * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed  * balance after interest accrual. Only callable by valid module.  * @param _setToken             Instance of the SetToken  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {     sync(_setToken); }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for  * module to return debt to issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be taken out twice potentially leading to liquidation     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);         _borrowForHook(_setToken, _component, notionalDebt);     } }  /**  * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after  * the issuance module transfers debt from the issuer. Only callable by valid module.  * @param _setToken             Instance of the SetToken  * @param _setTokenQuantity     Quantity of SetToken  * @param _component            Address of component  */ function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {     // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position     // exists the loan would be paid down twice, decollateralizing the Set     if (!_isEquity) {         int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));          require(componentDebt &lt; 0, "Component must be negative");          uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);         _repayBorrowForHook(_setToken, _component, notionalDebt);     } }  /* ============ External Getter Functions ============ */  /**  * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.  * @return Underlying collateral assets that are enabled  * @return Underlying borrowed assets that are enabled  */ function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {     return (         enabledAssets[_setToken].collateralAssets,         enabledAssets[_setToken].borrowAssets     ); }  /* ============ Internal Functions ============ */  /**  * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.  */ function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.  */ function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity); }  /**  * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.  */ function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);     _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.  */ function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {     _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE); }  /**  * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the  * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.  */ function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {     _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity); }  /**  * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken  * @return uint256     The quantity of tokens received post-trade  */ function _executeTrade(     ActionInfo memory _actionInfo,     IERC20 _sendToken,     IERC20 _receiveToken,     bytes memory _data )     internal     returns (uint256) {     ISetToken setToken = _actionInfo.setToken;     uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;      setToken.invokeApprove(         address(_sendToken),         _actionInfo.exchangeAdapter.getSpender(),         notionalSendQuantity     );      (         address targetExchange,         uint256 callValue,         bytes memory methodData     ) = _actionInfo.exchangeAdapter.getTradeCalldata(         address(_sendToken),         address(_receiveToken),         address(setToken),         notionalSendQuantity,         _actionInfo.minNotionalReceiveQuantity,         _data     );      setToken.invoke(targetExchange, callValue, methodData);      uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);     require(         receiveTokenQuantity &gt;= _actionInfo.minNotionalReceiveQuantity,         "Slippage too high"     );      return receiveTokenQuantity; }  /**  * @dev Calculates protocol fee on module and pays protocol fee from SetToken  * @return uint256          Total protocol fee paid  */ function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {     uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);      payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);      return protocolFeeTotal; }  /**  * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken  */ function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {     IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;     _updateCollateralPosition(         _actionInfo.setToken,         aToken,         _getCollateralPosition(             _actionInfo.setToken,             aToken,             _actionInfo.setTotalSupply         )     );      _updateBorrowPosition(         _actionInfo.setToken,         _borrowAsset,         _getBorrowPosition(             _actionInfo.setToken,             _borrowAsset,             _actionInfo.setTotalSupply         )     ); }  /**  * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is  * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.  */ function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {     // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position     uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));     if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {         _actionInfo.setToken.calculateAndEditDefaultPosition(             address(_repayAsset),             _actionInfo.setTotalSupply,             _actionInfo.preTradeReceiveTokenBalance         );     }      _updateLeverPositions(_actionInfo, _repayAsset); }  /**  * @dev Updates default position unit for given aToken on SetToken  */ function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {     _setToken.editDefaultPosition(address(_aToken), _newPositionUnit); }  /**  * @dev Updates external position unit for given borrow asset on SetToken  */ function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {     _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, ""); }  /**  * @dev Construct the ActionInfo struct for lever and delever  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfo(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _sendQuantityUnits,     uint256 _minReceiveQuantityUnits,     string memory _tradeAdapterName,     bool _isLever )     internal     view     returns(ActionInfo memory) {     uint256 totalSupply = _setToken.totalSupply();      return _createAndValidateActionInfoNotional(         _setToken,         _sendToken,         _receiveToken,         _sendQuantityUnits.preciseMul(totalSupply),         _minReceiveQuantityUnits.preciseMul(totalSupply),         _tradeAdapterName,         _isLever,         totalSupply     ); }  /**  * @dev Construct the ActionInfo struct for lever and delever accepting notional units  * @return ActionInfo       Instance of constructed ActionInfo struct  */ function _createAndValidateActionInfoNotional(     ISetToken _setToken,     IERC20 _sendToken,     IERC20 _receiveToken,     uint256 _notionalSendQuantity,     uint256 _minNotionalReceiveQuantity,     string memory _tradeAdapterName,     bool _isLever,     uint256 _setTotalSupply )     internal     view     returns(ActionInfo memory) {     ActionInfo memory actionInfo = ActionInfo ({         exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),         lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),         setToken: _setToken,         collateralAsset: _isLever ? _receiveToken : _sendToken,         borrowAsset: _isLever ? _sendToken : _receiveToken,         setTotalSupply: _setTotalSupply,         notionalSendQuantity: _notionalSendQuantity,         minNotionalReceiveQuantity: _minNotionalReceiveQuantity,         preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))     });      _validateCommon(actionInfo);      return actionInfo; }  /**  * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.  */ function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {     (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));     underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);     underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);      emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken)); }  /**  * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.  * Emits CollateralAssetsUpdated event.  */ function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {     for(uint256 i = 0; i &lt; _newCollateralAssets.length; i++) {         IERC20 collateralAsset = _newCollateralAssets[i];          _validateNewCollateralAsset(_setToken, collateralAsset);         _updateUseReserveAsCollateral(_setToken, collateralAsset, true);          collateralAssetEnabled[_setToken][collateralAsset] = true;         enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));     }     emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets); }  /**  * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.  * Emits BorrowAssetsUpdated event.  */ function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {     for(uint256 i = 0; i &lt; _newBorrowAssets.length; i++) {         IERC20 borrowAsset = _newBorrowAssets[i];          _validateNewBorrowAsset(_setToken, borrowAsset);          borrowAssetEnabled[_setToken][borrowAsset] = true;         enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));     }     emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets); }  /**  * @dev Updates SetToken's ability to use an asset as collateral on Aave  */ function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {     /*     Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. `to` address had zero aToken balance before the transfer         3. transfer `amount` is greater than 0      Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided         1. msg.sender (from address) isn't the same as `to` address         2. msg.sender has zero balance after the transfer      Different states of the SetToken and what this function does in those states:          Case 1: Manager adds collateral asset to SetToken before first issuance             - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave             requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral             on Aave markets.          Case 2: First issuance of the SetToken             - SetToken was initialized with aToken as default position             - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken             - Aave enables aToken to be used as collateral by the SetToken             - Manager calls lever() and the aToken is used as collateral to borrow other assets          Case 3: Manager removes collateral asset from the SetToken             - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with             useAsCollateral equals false             - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole             transaction reverts, and manager can't remove corresponding collateral asset          Case 4: Manager adds collateral asset after removing it             - If aToken.balanceOf(setToken) &gt; 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken             is re-enabled as collateral on Aave          Case 5: On redemption/delever/liquidated and aToken balance becomes zero             - Aave disables aToken to be used as collateral by SetToken      Values of variables in below if condition and corresponding action taken:      ---------------------------------------------------------------------------------------------------------------------     | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |     |                          |                   |                       |   collateral when aToken balance becomes 0 |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |     |--------------------------|-------------------|-----------------------|--------------------------------------------|     |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |     ---------------------------------------------------------------------------------------------------------------------     */     (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));     if (         usageAsCollateralEnabled != _useAsCollateral         &amp;&amp; underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) &gt; 0     ) {         _setToken.invokeSetUserUseReserveAsCollateral(             ILendingPool(lendingPoolAddressesProvider.getLendingPool()),             address(_asset),             _useAsCollateral         );     } }  /**  * @dev Validate common requirements for lever and delever  */ function _validateCommon(ActionInfo memory _actionInfo) internal view {     require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");     require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");     require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");     require(_actionInfo.notionalSendQuantity &gt; 0, "Quantity is 0"); }  /**  * @dev Validates if a new asset can be added as collateral asset for given SetToken  */ function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");      (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");      ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     // An active reserve is an alias for a valid reserve on Aave.     // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,     // because our mappings can be out-of-date if a new reserve is added to Aave     require(isActive, "Invalid aave reserve");     // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals     require(!isFrozen, "Frozen aave reserve");     require(usageAsCollateralEnabled, "Collateral disabled on Aave"); }  /**  * @dev Validates if a new asset can be added as borrow asset for given SetToken  */ function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {     require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");      ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));     require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");      (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));     require(isActive, "Invalid aave reserve");     require(!isFrozen, "Frozen aave reserve");     require(borrowingEnabled, "Borrowing disabled on Aave"); }  /**  * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken  *  * @return uint256       default collateral position unit  */ function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {     uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));     return collateralNotionalBalance.preciseDiv(_setTotalSupply); }  /**  * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken  *  * @return int256       external borrow position unit  */ function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {     uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));     return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 02:11:36 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: /*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "/*
    Copyright 2021 Set Labs Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    SPDX-License-Identifier: Apache License, Version 2.0
*/

pragma solidity 0.6.10;
pragma experimental "ABIEncoderV2";

import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { AaveV2 } from "../../integration/lib/AaveV2.sol";
import { IAToken } from "../../../interfaces/external/aave-v2/IAToken.sol";
import { IController } from "../../../interfaces/IController.sol";
import { IDebtIssuanceModule } from "../../../interfaces/IDebtIssuanceModule.sol";
import { IExchangeAdapter } from "../../../interfaces/IExchangeAdapter.sol";
import { ILendingPool } from "../../../interfaces/external/aave-v2/ILendingPool.sol";
import { ILendingPoolAddressesProvider } from "../../../interfaces/external/aave-v2/ILendingPoolAddressesProvider.sol";
import { IModuleIssuanceHook } from "../../../interfaces/IModuleIssuanceHook.sol";
import { IProtocolDataProvider } from "../../../interfaces/external/aave-v2/IProtocolDataProvider.sol";
import { ISetToken } from "../../../interfaces/ISetToken.sol";
import { IVariableDebtToken } from "../../../interfaces/external/aave-v2/IVariableDebtToken.sol";
import { ModuleBase } from "../../lib/ModuleBase.sol";

/**
 * @title AaveLeverageModule
 * @author Set Protocol
 * @notice Smart contract that enables leverage trading using Aave as the lending protocol.
 * @dev Do not use this module in conjunction with other debt modules that allow Aave debt positions as it could lead to double counting of
 * debt when borrowed assets are the same.
 */
contract AaveLeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {
    using AaveV2 for ISetToken;

    /* ============ Structs ============ */

    struct EnabledAssets {
        address[] collateralAssets;             // Array of enabled underlying collateral assets for a SetToken
        address[] borrowAssets;                 // Array of enabled underlying borrow assets for a SetToken
    }

    struct ActionInfo {
        ISetToken setToken;                      // SetToken instance
        ILendingPool lendingPool;                // Lending pool instance, we grab this everytime since it's best practice not to store
        IExchangeAdapter exchangeAdapter;        // Exchange adapter instance
        uint256 setTotalSupply;                  // Total supply of SetToken
        uint256 notionalSendQuantity;            // Total notional quantity sent to exchange
        uint256 minNotionalReceiveQuantity;      // Min total notional received from exchange
        IERC20 collateralAsset;                  // Address of collateral asset
        IERC20 borrowAsset;                      // Address of borrow asset
        uint256 preTradeReceiveTokenBalance;     // Balance of pre-trade receive token balance
    }

    struct ReserveTokens {
        IAToken aToken;                         // Reserve's aToken instance
        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance
    }

    /* ============ Events ============ */

    /**
     * @dev Emitted on lever()
     * @param _setToken             Instance of the SetToken being levered
     * @param _borrowAsset          Asset being borrowed for leverage
     * @param _collateralAsset      Collateral asset being levered
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalBorrowAmount    Total amount of `_borrowAsset` borrowed
     * @param _totalReceiveAmount   Total amount of `_collateralAsset` received by selling `_borrowAsset`
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageIncreased(
        ISetToken indexed _setToken,
        IERC20 indexed _borrowAsset,
        IERC20 indexed _collateralAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalBorrowAmount,
        uint256 _totalReceiveAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on delever() and deleverToZeroBorrowBalance()
     * @param _setToken             Instance of the SetToken being delevered
     * @param _collateralAsset      Asset sold to decrease leverage
     * @param _repayAsset           Asset being bought to repay to Aave
     * @param _exchangeAdapter      Exchange adapter used for trading
     * @param _totalRedeemAmount    Total amount of `_collateralAsset` being sold
     * @param _totalRepayAmount     Total amount of `_repayAsset` being repaid
     * @param _protocolFee          Protocol fee charged
     */
    event LeverageDecreased(
        ISetToken indexed _setToken,
        IERC20 indexed _collateralAsset,
        IERC20 indexed _repayAsset,
        IExchangeAdapter _exchangeAdapter,
        uint256 _totalRedeemAmount,
        uint256 _totalRepayAmount,
        uint256 _protocolFee
    );

    /**
     * @dev Emitted on addCollateralAssets() and removeCollateralAssets()
     * @param _setToken Instance of SetToken whose collateral assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of collateral assets being added/removed
     */
    event CollateralAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted on addBorrowAssets() and removeBorrowAssets()
     * @param _setToken Instance of SetToken whose borrow assets is updated
     * @param _added    true if assets are added false if removed
     * @param _assets   Array of borrow assets being added/removed
     */
    event BorrowAssetsUpdated(
        ISetToken indexed _setToken,
        bool indexed _added,
        IERC20[] _assets
    );

    /**
     * @dev Emitted when `underlyingToReserveTokensMappings` is updated
     * @param _underlying           Address of the underlying asset
     * @param _aToken               Updated aave reserve aToken
     * @param _variableDebtToken    Updated aave reserve variable debt token
     */
    event ReserveTokensUpdated(
        IERC20 indexed _underlying,
        IAToken indexed _aToken,
        IVariableDebtToken indexed _variableDebtToken
    );

    /**
     * @dev Emitted on updateAllowedSetToken()
     * @param _setToken SetToken being whose allowance to initialize this module is being updated
     * @param _added    true if added false if removed
     */
    event SetTokenStatusUpdated(
        ISetToken indexed _setToken,
        bool indexed _added
    );

    /**
     * @dev Emitted on updateAnySetAllowed()
     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise
     */
    event AnySetAllowedUpdated(
        bool indexed _anySetAllowed
    );

    /* ============ Constants ============ */

    // This module only supports borrowing in variable rate mode from Aave which is represented by 2
    uint256 constant internal BORROW_RATE_MODE = 2;

    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as
    // the string as the integration name
    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = "DefaultIssuanceModule";

    // 0 index stores protocol fee % on the controller, charged in the _executeTrade function
    uint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;

    /* ============ State Variables ============ */

    // Mapping to efficiently fetch reserve token addresses. Tracking Aave reserve token addresses and updating them
    // upon requirement is more efficient than fetching them each time from Aave.
    // Note: For an underlying asset to be enabled as collateral/borrow asset on SetToken, it must be added to this mapping first.
    mapping(IERC20 => ReserveTokens) public underlyingToReserveTokens;

    // Used to fetch reserves and user data from AaveV2
    IProtocolDataProvider public immutable protocolDataProvider;

    // Used to fetch lendingPool address. This contract is immutable and its address will never change.
    ILendingPoolAddressesProvider public immutable lendingPoolAddressesProvider;

    // Mapping to efficiently check if collateral asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public collateralAssetEnabled;

    // Mapping to efficiently check if a borrow asset is enabled in SetToken
    mapping(ISetToken => mapping(IERC20 => bool)) public borrowAssetEnabled;

    // Internal mapping of enabled collateral and borrow tokens for syncing positions
    mapping(ISetToken => EnabledAssets) internal enabledAssets;

    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance
    mapping(ISetToken => bool) public allowedSetTokens;

    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.
    bool public anySetAllowed;

    /* ============ Constructor ============ */

    /**
     * @dev Instantiate addresses. Underlying to reserve tokens mapping is created.
     * @param _controller                       Address of controller contract
     * @param _lendingPoolAddressesProvider     Address of Aave LendingPoolAddressProvider
     */
    constructor(
        IController _controller,
        ILendingPoolAddressesProvider _lendingPoolAddressesProvider
    )
        public
        ModuleBase(_controller)
    {
        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;
        IProtocolDataProvider _protocolDataProvider = IProtocolDataProvider(
            // Use the raw input vs bytes32() conversion. This is to ensure the input is an uint and not a string.
            _lendingPoolAddressesProvider.getAddress(0x0100000000000000000000000000000000000000000000000000000000000000)
        );
        protocolDataProvider = _protocolDataProvider;

        IProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();
        for(uint256 i = 0; i < reserveTokens.length; i++) {
            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);
            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken));
        }
    }

    /* ============ External Functions ============ */

    /**
     * @dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.
     * Borrows _borrowAsset from Aave. Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset.
     * Deposits _collateralAsset to Aave and mints corresponding aToken.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                     Instance of the SetToken
     * @param _borrowAsset                  Address of underlying asset being borrowed for leverage
     * @param _collateralAsset              Address of underlying collateral asset
     * @param _borrowQuantityUnits          Borrow quantity of asset in position units
     * @param _minReceiveQuantityUnits      Min receive quantity of collateral asset to receive post-trade in position units
     * @param _tradeAdapterName             Name of trade adapter
     * @param _tradeData                    Arbitrary data for trade
     */
    function lever(
        ISetToken _setToken,
        IERC20 _borrowAsset,
        IERC20 _collateralAsset,
        uint256 _borrowQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from
        // collateral asset
        ActionInfo memory leverInfo = _createAndValidateActionInfo(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            _borrowQuantityUnits,
            _minReceiveQuantityUnits,
            _tradeAdapterName,
            true
        );

        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);

        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);

        _updateLeverPositions(leverInfo, _borrowAsset);

        emit LeverageIncreased(
            _setToken,
            _borrowAsset,
            _collateralAsset,
            leverInfo.exchangeAdapter,
            leverInfo.notionalSendQuantity,
            postTradeCollateralQuantity,
            protocolFee
        );
    }

    /**
     * @dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Repays _repayAsset to Aave and burns corresponding debt tokens.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * @param _setToken                 Instance of the SetToken
     * @param _collateralAsset          Address of underlying collateral asset being withdrawn
     * @param _repayAsset               Address of underlying borrowed asset being repaid
     * @param _redeemQuantityUnits      Quantity of collateral asset to delever in position units
     * @param _minRepayQuantityUnits    Minimum amount of repay asset to receive post trade in position units
     * @param _tradeAdapterName         Name of trade adapter
     * @param _tradeData                Arbitrary data for trade
     */
    function delever(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        uint256 _minRepayQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
    {
        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from
        // repay asset
        ActionInfo memory deleverInfo = _createAndValidateActionInfo(
            _setToken,
            _collateralAsset,
            _repayAsset,
            _redeemQuantityUnits,
            _minRepayQuantityUnits,
            _tradeAdapterName,
            false
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);

        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            repayQuantity,
            protocolFee
        );
    }

    /** @dev MANAGER ONLY: Pays down the borrow asset to 0 selling off a given amount of collateral asset.
     * Withdraws _collateralAsset from Aave. Performs a DEX trade, exchanging the _collateralAsset for _repayAsset.
     * Minimum receive amount for the DEX trade is set to the current variable debt balance of the borrow asset.
     * Repays received _repayAsset to Aave which burns corresponding debt tokens. Any extra received borrow asset is .
     * updated as equity. No protocol fee is charged.
     * Note: Both collateral and borrow assets need to be enabled, and they must not be the same asset.
     * The function reverts if not enough collateral asset is redeemed to buy the required minimum amount of _repayAsset.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAsset      Address of underlying collateral asset being redeemed
     * @param _repayAsset           Address of underlying asset being repaid
     * @param _redeemQuantityUnits  Quantity of collateral asset to delever in position units
     * @param _tradeAdapterName     Name of trade adapter
     * @param _tradeData            Arbitrary data for trade
     * @return uint256              Notional repay quantity
     */
    function deleverToZeroBorrowBalance(
        ISetToken _setToken,
        IERC20 _collateralAsset,
        IERC20 _repayAsset,
        uint256 _redeemQuantityUnits,
        string memory _tradeAdapterName,
        bytes memory _tradeData
    )
        external
        nonReentrant
        onlyManagerAndValidSet(_setToken)
        returns (uint256)
    {
        uint256 setTotalSupply = _setToken.totalSupply();
        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);

        require(borrowAssetEnabled[_setToken][_repayAsset], "Borrow not enabled");
        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));
        require(notionalRepayQuantity > 0, "Borrow balance is zero");

        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(
            _setToken,
            _collateralAsset,
            _repayAsset,
            notionalRedeemQuantity,
            notionalRepayQuantity,
            _tradeAdapterName,
            false,
            setTotalSupply
        );

        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);

        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);

        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);

        _updateDeleverPositions(deleverInfo, _repayAsset);

        emit LeverageDecreased(
            _setToken,
            _collateralAsset,
            _repayAsset,
            deleverInfo.exchangeAdapter,
            deleverInfo.notionalSendQuantity,
            notionalRepayQuantity,
            0   // No protocol fee
        );

        return notionalRepayQuantity;
    }

    /**
     * @dev CALLABLE BY ANYBODY: Sync Set positions with ALL enabled Aave collateral and borrow positions.
     * For collateral assets, update aToken default position. For borrow assets, update external borrow position.
     * - Collateral assets may come out of sync when interest is accrued or a position is liquidated
     * - Borrow assets may come out of sync when interest is accrued or position is liquidated and borrow is repaid
     * Note: In Aave, both collateral and borrow interest is accrued in each block by increasing the balance of
     * aTokens and debtTokens for each user, and 1 aToken = 1 variableDebtToken = 1 underlying.
     * @param _setToken               Instance of the SetToken
     */
    function sync(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {
        uint256 setTotalSupply = _setToken.totalSupply();

        // Only sync positions when Set supply is not 0. Without this check, if sync is called by someone before the
        // first issuance, then editDefaultPosition would remove the default positions from the SetToken
        if (setTotalSupply > 0) {
            address[] memory collateralAssets = enabledAssets[_setToken].collateralAssets;
            for(uint256 i = 0; i < collateralAssets.length; i++) {
                IAToken aToken = underlyingToReserveTokens[IERC20(collateralAssets[i])].aToken;

                uint256 previousPositionUnit = _setToken.getDefaultPositionRealUnit(address(aToken)).toUint256();
                uint256 newPositionUnit = _getCollateralPosition(_setToken, aToken, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (previousPositionUnit != newPositionUnit) {
                  _updateCollateralPosition(_setToken, aToken, newPositionUnit);
                }
            }

            address[] memory borrowAssets = enabledAssets[_setToken].borrowAssets;
            for(uint256 i = 0; i < borrowAssets.length; i++) {
                IERC20 borrowAsset = IERC20(borrowAssets[i]);

                int256 previousPositionUnit = _setToken.getExternalPositionRealUnit(address(borrowAsset), address(this));
                int256 newPositionUnit = _getBorrowPosition(_setToken, borrowAsset, setTotalSupply);

                // Note: Accounts for if position does not exist on SetToken but is tracked in enabledAssets
                if (newPositionUnit != previousPositionUnit) {
                    _updateBorrowPosition(_setToken, borrowAsset, newPositionUnit);
                }
            }
        }
    }

    /**
     * @dev MANAGER ONLY: Initializes this module to the SetToken. Either the SetToken needs to be on the allowed list
     * or anySetAllowed needs to be true. Only callable by the SetToken's manager.
     * Note: Managers can enable collateral and borrow assets that don't exist as positions on the SetToken
     * @param _setToken             Instance of the SetToken to initialize
     * @param _collateralAssets     Underlying tokens to be enabled as collateral in the SetToken
     * @param _borrowAssets         Underlying tokens to be enabled as borrow in the SetToken
     */
    function initialize(
        ISetToken _setToken,
        IERC20[] memory _collateralAssets,
        IERC20[] memory _borrowAssets
    )
        external
        onlySetManager(_setToken, msg.sender)
        onlyValidAndPendingSet(_setToken)
    {
        if (!anySetAllowed) {
            require(allowedSetTokens[_setToken], "Not allowed SetToken");
        }

        // Initialize module before trying register
        _setToken.initializeModule();

        // Get debt issuance module registered to this module and require that it is initialized
        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), "Issuance not initialized");

        // Try if register exists on any of the modules including the debt issuance module
        address[] memory modules = _setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}
        }

        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions
        _addCollateralAssets(_setToken, _collateralAssets);
        _addBorrowAssets(_setToken, _borrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Any deposited collateral assets
     * are disabled to be used as collateral on Aave. Aave Settings and manager enabled assets state is deleted.
     * Note: Function will revert is there is any debt remaining on Aave
     */
    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {
        ISetToken setToken = ISetToken(msg.sender);

        // Sync Aave and SetToken positions prior to any removal action
        sync(setToken);

        address[] memory borrowAssets = enabledAssets[setToken].borrowAssets;
        for(uint256 i = 0; i < borrowAssets.length; i++) {
            IERC20 borrowAsset = IERC20(borrowAssets[i]);
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[setToken][borrowAsset];
        }

        address[] memory collateralAssets = enabledAssets[setToken].collateralAssets;
        for(uint256 i = 0; i < collateralAssets.length; i++) {
            IERC20 collateralAsset = IERC20(collateralAssets[i]);
            _updateUseReserveAsCollateral(setToken, collateralAsset, false);

            delete collateralAssetEnabled[setToken][collateralAsset];
        }

        delete enabledAssets[setToken];

        // Try if unregister exists on any of the modules
        address[] memory modules = setToken.getModules();
        for(uint256 i = 0; i < modules.length; i++) {
            try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}
        }
    }

    /**
     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.
     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function
     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies
     * @param _setToken             Instance of the SetToken
     * @param _debtIssuanceModule   Debt issuance module address to register
     */
    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {
        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), "Issuance not initialized");

        _debtIssuanceModule.registerToIssuanceModule(_setToken);
    }

    /**
     * @dev CALLABLE BY ANYBODY: Updates `underlyingToReserveTokens` mappings. Reverts if mapping already exists
     * or the passed _underlying asset does not have a valid reserve on Aave.
     * Note: Call this function when Aave adds a new reserve.
     * @param _underlying               Address of underlying asset
     */
    function addUnderlyingToReserveTokensMapping(IERC20 _underlying) external {
        require(address(underlyingToReserveTokens[_underlying].aToken) == address(0), "Mapping already exists");

        // An active reserve is an alias for a valid reserve on Aave.
        (,,,,,,,, bool isActive,) = protocolDataProvider.getReserveConfigurationData(address(_underlying));
        require(isActive, "Invalid aave reserve");

        _addUnderlyingToReserveTokensMapping(_underlying);
    }

    /**
     * @dev MANAGER ONLY: Add collateral assets. aTokens corresponding to collateral assets are tracked for syncing positions.
     * Note: Reverts with "Collateral already enabled" if there are duplicate assets in the passed _newCollateralAssets array.
     *
     * NOTE: ALL ADDED COLLATERAL ASSETS CAN BE ADDED AS A POSITION ON THE SET TOKEN WITHOUT MANAGER'S EXPLICIT PERMISSION.
     * UNWANTED EXTRA POSITIONS CAN BREAK EXTERNAL LOGIC, INCREASE COST OF MINT/REDEEM OF SET TOKEN, AMONG OTHER POTENTIAL UNINTENDED CONSEQUENCES.
     * SO, PLEASE ADD ONLY THOSE COLLATERAL ASSETS WHOSE CORRESPONDING aTOKENS ARE NEEDED AS DEFAULT POSITIONS ON THE SET TOKEN.
     *
     * @param _setToken             Instance of the SetToken
     * @param _newCollateralAssets  Addresses of new collateral underlying assets
     */
    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {
        _addCollateralAssets(_setToken, _newCollateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.
     * @param _setToken             Instance of the SetToken
     * @param _collateralAssets     Addresses of collateral underlying assets to remove
     */
    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _collateralAssets.length; i++) {
            IERC20 collateralAsset = _collateralAssets[i];
            require(collateralAssetEnabled[_setToken][collateralAsset], "Collateral not enabled");

            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);

            delete collateralAssetEnabled[_setToken][collateralAsset];
            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);
    }

    /**
     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.
     * Note: Reverts with "Borrow already enabled" if there are duplicate assets in the passed _newBorrowAssets array.
     * @param _setToken             Instance of the SetToken
     * @param _newBorrowAssets      Addresses of borrow underlying assets to add
     */
    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {
        _addBorrowAssets(_setToken, _newBorrowAssets);
    }

    /**
     * @dev MANAGER ONLY: Remove borrow assets.
     * Note: If there is a borrow balance, borrow asset cannot be removed
     * @param _setToken             Instance of the SetToken
     * @param _borrowAssets         Addresses of borrow underlying assets to remove
     */
    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {

        for(uint256 i = 0; i < _borrowAssets.length; i++) {
            IERC20 borrowAsset = _borrowAssets[i];

            require(borrowAssetEnabled[_setToken][borrowAsset], "Borrow not enabled");
            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, "Variable debt remaining");

            delete borrowAssetEnabled[_setToken][borrowAsset];
            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);
    }

    /**
     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.
     * @param _setToken             Instance of the SetToken
     * @param _status               Bool indicating if _setToken is allowed to initialize this module
     */
    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {
        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], "Invalid SetToken");
        allowedSetTokens[_setToken] = _status;
        emit SetTokenStatusUpdated(_setToken, _status);
    }

    /**
     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.
     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module
     */
    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {
        anySetAllowed = _anySetAllowed;
        emit AnySetAllowedUpdated(_anySetAllowed);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to issuance to sync positions on SetToken. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to redemption to sync positions on SetToken. For redemption, always use current borrowed
     * balance after interest accrual. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     */
    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenQuantity */) external override onlyModule(_setToken) {
        sync(_setToken);
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on issuance. Invokes borrow in order for
     * module to return debt to issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be taken out twice potentially leading to liquidation
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);
            _borrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /**
     * @dev MODULE ONLY: Hook called prior to looping through each component on redemption. Invokes repay after
     * the issuance module transfers debt from the issuer. Only callable by valid module.
     * @param _setToken             Instance of the SetToken
     * @param _setTokenQuantity     Quantity of SetToken
     * @param _component            Address of component
     */
    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {
        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position
        // exists the loan would be paid down twice, decollateralizing the Set
        if (!_isEquity) {
            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));

            require(componentDebt < 0, "Component must be negative");

            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);
            _repayBorrowForHook(_setToken, _component, notionalDebt);
        }
    }

    /* ============ External Getter Functions ============ */

    /**
     * @dev Get enabled assets for SetToken. Returns an array of collateral and borrow assets.
     * @return Underlying collateral assets that are enabled
     * @return Underlying borrowed assets that are enabled
     */
    function getEnabledAssets(ISetToken _setToken) external view returns(address[] memory, address[] memory) {
        return (
            enabledAssets[_setToken].collateralAssets,
            enabledAssets[_setToken].borrowAssets
        );
    }

    /* ============ Internal Functions ============ */

    /**
     * @dev Invoke deposit from SetToken using AaveV2 library. Mints aTokens for SetToken.
     */
    function _deposit(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeDeposit(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke withdraw from SetToken using AaveV2 library. Burns aTokens and returns underlying to SetToken.
     */
    function _withdraw(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeWithdraw(_lendingPool, address(_asset), _notionalQuantity);
    }

    /**
     * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.
     */
    function _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);
        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _repayBorrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invoke borrow from the SetToken using AaveV2 library. Mints DebtTokens for SetToken.
     */
    function _borrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {
        _setToken.invokeBorrow(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);
    }

    /**
     * @dev Invoke borrow from the SetToken during issuance hook. Since we only need to interact with AAVE once we fetch the
     * lending pool in this function to optimize vs forcing a fetch twice during lever/delever.
     */
    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {
        _borrow(_setToken, ILendingPool(lendingPoolAddressesProvider.getLendingPool()), _asset, _notionalQuantity);
    }

    /**
     * @dev Invokes approvals, gets trade call data from exchange adapter and invokes trade from SetToken
     * @return uint256     The quantity of tokens received post-trade
     */
    function _executeTrade(
        ActionInfo memory _actionInfo,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        bytes memory _data
    )
        internal
        returns (uint256)
    {
        ISetToken setToken = _actionInfo.setToken;
        uint256 notionalSendQuantity = _actionInfo.notionalSendQuantity;

        setToken.invokeApprove(
            address(_sendToken),
            _actionInfo.exchangeAdapter.getSpender(),
            notionalSendQuantity
        );

        (
            address targetExchange,
            uint256 callValue,
            bytes memory methodData
        ) = _actionInfo.exchangeAdapter.getTradeCalldata(
            address(_sendToken),
            address(_receiveToken),
            address(setToken),
            notionalSendQuantity,
            _actionInfo.minNotionalReceiveQuantity,
            _data
        );

        setToken.invoke(targetExchange, callValue, methodData);

        uint256 receiveTokenQuantity = _receiveToken.balanceOf(address(setToken)).sub(_actionInfo.preTradeReceiveTokenBalance);
        require(
            receiveTokenQuantity >= _actionInfo.minNotionalReceiveQuantity,
            "Slippage too high"
        );

        return receiveTokenQuantity;
    }

    /**
     * @dev Calculates protocol fee on module and pays protocol fee from SetToken
     * @return uint256          Total protocol fee paid
     */
    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {
        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);

        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);

        return protocolFeeTotal;
    }

    /**
     * @dev Updates the collateral (aToken held) and borrow position (variableDebtToken held) of the SetToken
     */
    function _updateLeverPositions(ActionInfo memory _actionInfo, IERC20 _borrowAsset) internal {
        IAToken aToken = underlyingToReserveTokens[_actionInfo.collateralAsset].aToken;
        _updateCollateralPosition(
            _actionInfo.setToken,
            aToken,
            _getCollateralPosition(
                _actionInfo.setToken,
                aToken,
                _actionInfo.setTotalSupply
            )
        );

        _updateBorrowPosition(
            _actionInfo.setToken,
            _borrowAsset,
            _getBorrowPosition(
                _actionInfo.setToken,
                _borrowAsset,
                _actionInfo.setTotalSupply
            )
        );
    }

    /**
     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is
     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.
     */
    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {
        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position
        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));
        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {
            _actionInfo.setToken.calculateAndEditDefaultPosition(
                address(_repayAsset),
                _actionInfo.setTotalSupply,
                _actionInfo.preTradeReceiveTokenBalance
            );
        }

        _updateLeverPositions(_actionInfo, _repayAsset);
    }

    /**
     * @dev Updates default position unit for given aToken on SetToken
     */
    function _updateCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _newPositionUnit) internal {
        _setToken.editDefaultPosition(address(_aToken), _newPositionUnit);
    }

    /**
     * @dev Updates external position unit for given borrow asset on SetToken
     */
    function _updateBorrowPosition(ISetToken _setToken, IERC20 _underlyingAsset, int256 _newPositionUnit) internal {
        _setToken.editExternalPosition(address(_underlyingAsset), address(this), _newPositionUnit, "");
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfo(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _sendQuantityUnits,
        uint256 _minReceiveQuantityUnits,
        string memory _tradeAdapterName,
        bool _isLever
    )
        internal
        view
        returns(ActionInfo memory)
    {
        uint256 totalSupply = _setToken.totalSupply();

        return _createAndValidateActionInfoNotional(
            _setToken,
            _sendToken,
            _receiveToken,
            _sendQuantityUnits.preciseMul(totalSupply),
            _minReceiveQuantityUnits.preciseMul(totalSupply),
            _tradeAdapterName,
            _isLever,
            totalSupply
        );
    }

    /**
     * @dev Construct the ActionInfo struct for lever and delever accepting notional units
     * @return ActionInfo       Instance of constructed ActionInfo struct
     */
    function _createAndValidateActionInfoNotional(
        ISetToken _setToken,
        IERC20 _sendToken,
        IERC20 _receiveToken,
        uint256 _notionalSendQuantity,
        uint256 _minNotionalReceiveQuantity,
        string memory _tradeAdapterName,
        bool _isLever,
        uint256 _setTotalSupply
    )
        internal
        view
        returns(ActionInfo memory)
    {
        ActionInfo memory actionInfo = ActionInfo ({
            exchangeAdapter: IExchangeAdapter(getAndValidateAdapter(_tradeAdapterName)),
            lendingPool: ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
            setToken: _setToken,
            collateralAsset: _isLever ? _receiveToken : _sendToken,
            borrowAsset: _isLever ? _sendToken : _receiveToken,
            setTotalSupply: _setTotalSupply,
            notionalSendQuantity: _notionalSendQuantity,
            minNotionalReceiveQuantity: _minNotionalReceiveQuantity,
            preTradeReceiveTokenBalance: IERC20(_receiveToken).balanceOf(address(_setToken))
        });

        _validateCommon(actionInfo);

        return actionInfo;
    }

    /**
     * @dev Updates `underlyingToReserveTokens` mappings for given `_underlying` asset. Emits ReserveTokensUpdated event.
     */
    function _addUnderlyingToReserveTokensMapping(IERC20 _underlying) internal {
        (address aToken, , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_underlying));
        underlyingToReserveTokens[_underlying].aToken = IAToken(aToken);
        underlyingToReserveTokens[_underlying].variableDebtToken = IVariableDebtToken(variableDebtToken);

        emit ReserveTokensUpdated(_underlying, IAToken(aToken), IVariableDebtToken(variableDebtToken));
    }

    /**
     * @dev Add collateral assets to SetToken. Updates the collateralAssetsEnabled and enabledAssets mappings.
     * Emits CollateralAssetsUpdated event.
     */
    function _addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) internal {
        for(uint256 i = 0; i < _newCollateralAssets.length; i++) {
            IERC20 collateralAsset = _newCollateralAssets[i];

            _validateNewCollateralAsset(_setToken, collateralAsset);
            _updateUseReserveAsCollateral(_setToken, collateralAsset, true);

            collateralAssetEnabled[_setToken][collateralAsset] = true;
            enabledAssets[_setToken].collateralAssets.push(address(collateralAsset));
        }
        emit CollateralAssetsUpdated(_setToken, true, _newCollateralAssets);
    }

    /**
     * @dev Add borrow assets to SetToken. Updates the borrowAssetsEnabled and enabledAssets mappings.
     * Emits BorrowAssetsUpdated event.
     */
    function _addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) internal {
        for(uint256 i = 0; i < _newBorrowAssets.length; i++) {
            IERC20 borrowAsset = _newBorrowAssets[i];

            _validateNewBorrowAsset(_setToken, borrowAsset);

            borrowAssetEnabled[_setToken][borrowAsset] = true;
            enabledAssets[_setToken].borrowAssets.push(address(borrowAsset));
        }
        emit BorrowAssetsUpdated(_setToken, true, _newBorrowAssets);
    }

    /**
     * @dev Updates SetToken's ability to use an asset as collateral on Aave
     */
    function _updateUseReserveAsCollateral(ISetToken _setToken, IERC20 _asset, bool _useAsCollateral) internal {
        /*
        Note: Aave ENABLES an asset to be used as collateral by `to` address in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. `to` address had zero aToken balance before the transfer
            3. transfer `amount` is greater than 0

        Note: Aave DISABLES an asset to be used as collateral by `msg.sender`in an `aToken.transfer(to, amount)` call provided
            1. msg.sender (from address) isn't the same as `to` address
            2. msg.sender has zero balance after the transfer

        Different states of the SetToken and what this function does in those states:

            Case 1: Manager adds collateral asset to SetToken before first issuance
                - Since aToken.balanceOf(setToken) == 0, we do not call `setToken.invokeUserUseReserveAsCollateral` because Aave
                requires aToken balance to be greater than 0 before enabling/disabling the underlying asset to be used as collateral
                on Aave markets.

            Case 2: First issuance of the SetToken
                - SetToken was initialized with aToken as default position
                - DebtIssuanceModule reads the default position and transfers corresponding aToken from the issuer to the SetToken
                - Aave enables aToken to be used as collateral by the SetToken
                - Manager calls lever() and the aToken is used as collateral to borrow other assets

            Case 3: Manager removes collateral asset from the SetToken
                - Disable asset to be used as collateral on SetToken by calling `setToken.invokeSetUserUseReserveAsCollateral` with
                useAsCollateral equals false
                - Note: If health factor goes below 1 by removing the collateral asset, then Aave reverts on the above call, thus whole
                transaction reverts, and manager can't remove corresponding collateral asset

            Case 4: Manager adds collateral asset after removing it
                - If aToken.balanceOf(setToken) > 0, we call `setToken.invokeUserUseReserveAsCollateral` and the corresponding aToken
                is re-enabled as collateral on Aave

            Case 5: On redemption/delever/liquidated and aToken balance becomes zero
                - Aave disables aToken to be used as collateral by SetToken

        Values of variables in below if condition and corresponding action taken:

        ---------------------------------------------------------------------------------------------------------------------
        | usageAsCollateralEnabled |  _useAsCollateral |   aToken.balanceOf()  |     Action                                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   true            |      X                |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   greater than 0      |   Invoke and set to false.                 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   true                   |   false           |   = 0                 |   Impossible case. Aave disables usage as  |
        |                          |                   |                       |   collateral when aToken balance becomes 0 |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   false           |     X                 |   Skip invoke. Save gas.                   |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   greater than 0      |   Invoke and set to true.                  |
        |--------------------------|-------------------|-----------------------|--------------------------------------------|
        |   false                  |   true            |   = 0                 |   Don't invoke. Will revert.               |
        ---------------------------------------------------------------------------------------------------------------------
        */
        (,,,,,,,,bool usageAsCollateralEnabled) = protocolDataProvider.getUserReserveData(address(_asset), address(_setToken));
        if (
            usageAsCollateralEnabled != _useAsCollateral
            && underlyingToReserveTokens[_asset].aToken.balanceOf(address(_setToken)) > 0
        ) {
            _setToken.invokeSetUserUseReserveAsCollateral(
                ILendingPool(lendingPoolAddressesProvider.getLendingPool()),
                address(_asset),
                _useAsCollateral
            );
        }
    }

    /**
     * @dev Validate common requirements for lever and delever
     */
    function _validateCommon(ActionInfo memory _actionInfo) internal view {
        require(collateralAssetEnabled[_actionInfo.setToken][_actionInfo.collateralAsset], "Collateral not enabled");
        require(borrowAssetEnabled[_actionInfo.setToken][_actionInfo.borrowAsset], "Borrow not enabled");
        require(_actionInfo.collateralAsset != _actionInfo.borrowAsset, "Collateral and borrow asset must be different");
        require(_actionInfo.notionalSendQuantity > 0, "Quantity is 0");
    }

    /**
     * @dev Validates if a new asset can be added as collateral asset for given SetToken
     */
    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!collateralAssetEnabled[_setToken][_asset], "Collateral already enabled");

        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, "Invalid aToken address");

        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        // An active reserve is an alias for a valid reserve on Aave.
        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,
        // because our mappings can be out-of-date if a new reserve is added to Aave
        require(isActive, "Invalid aave reserve");
        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals
        require(!isFrozen, "Frozen aave reserve");
        require(usageAsCollateralEnabled, "Collateral disabled on Aave");
    }

    /**
     * @dev Validates if a new asset can be added as borrow asset for given SetToken
     */
    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {
        require(!borrowAssetEnabled[_setToken][_asset], "Borrow already enabled");

        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));
        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, "Invalid variable debt token address");

        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));
        require(isActive, "Invalid aave reserve");
        require(!isFrozen, "Frozen aave reserve");
        require(borrowingEnabled, "Borrowing disabled on Aave");
    }

    /**
     * @dev Reads aToken balance and calculates default position unit for given collateral aToken and SetToken
     *
     * @return uint256       default collateral position unit
     */
    function _getCollateralPosition(ISetToken _setToken, IAToken _aToken, uint256 _setTotalSupply) internal view returns (uint256) {
        uint256 collateralNotionalBalance = _aToken.balanceOf(address(_setToken));
        return collateralNotionalBalance.preciseDiv(_setTotalSupply);
    }

    /**
     * @dev Reads variableDebtToken balance and calculates external position unit for given borrow asset and SetToken
     *
     * @return int256       external borrow position unit
     */
    function _getBorrowPosition(ISetToken _setToken, IERC20 _borrowAsset, uint256 _setTotalSupply) internal view returns (int256) {
        uint256 borrowNotionalBalance = underlyingToReserveTokens[_borrowAsset].variableDebtToken.balanceOf(address(_setToken));
        return borrowNotionalBalance.preciseDivCeil(_setTotalSupply).toInt256().mul(-1);
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

