[2024-01-09 17:02:04 INFO] **[Preprocessing]**

**ChatDev Starts** (20240901170204)

**Timestamp**: 20240901170204

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}


**project_name**: RealWorld_BA_143_JBController

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_143_JBController_RealWord_20240901170204.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-01-09 17:02:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  / \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /* \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.\n          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there's an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle's properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:05 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-01-09 17:02:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18530
completion_tokens: 1
total_tokens: 18531
cost: $-1.000000


[2024-01-09 17:02:08 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Let's

[2024-01-09 17:02:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/utils/introspection/ERC165.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./abstract/JBOperatable.sol\';\nimport \'./interfaces/IJBController.sol\';\nimport \'./interfaces/IJBMigratable.sol\';\nimport \'./interfaces/IJBOperatorStore.sol\';\nimport \'./interfaces/IJBPaymentTerminal.sol\';\nimport \'./interfaces/IJBProjects.sol\';\nimport \'./libraries/JBConstants.sol\';\nimport \'./libraries/JBFundingCycleMetadataResolver.sol\';\nimport \'./libraries/JBOperations.sol\';\nimport \'./libraries/JBSplitsGroups.sol\';\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol\'s rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project\'s token\'s total supply is the amount of tokens that still need to have reserves minted against them.\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n  /\n    @notice\n    Mints ERC-721\'s that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it\'s in terms of.\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it\'s in terms of.\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n  / \n    @notice\n    A project\'s funding cycle for the specified configuration along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle\'s metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n  / \n    @notice\n    A project\'s latest configured funding cycle along with its metadata and the ballot state of the configuration.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle\'s metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  / \n    @notice\n    A project\'s current funding cycle along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle\'s metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  /* \n    @notice\n    A project\'s queued funding cycle along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle\'s metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n    @dev \n    See {IERC165-supportsInterface}.\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721\'s that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner\'s account, configure a first funding cycle, and set up any splits.\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n    @dev\n    Anyone can deploy a project on an owner\'s behalf.\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project\'s first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n    // Set this contract as the project\'s controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project\'s first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n    // Set this contract as the project\'s controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle\'s ballot.\n    @dev\n    Only a project\'s owner or a designated operator can configure its funding cycles.\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Issues an owner\'s ERC20 JBTokens that\'ll be used when claiming tokens.\n    @dev\n    Deploys a project\'s ERC20 JBToken contract.\n    @dev\n    Only a project\'s owner or operator can issue its token.\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20\'s name.\n    @param _symbol The ERC20\'s symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n  /\n    @notice\n    Swap the current project\'s token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n    @dev\n    Only a project\'s owner or operator can change its token.\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token\'s ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project\'s current funding cycle configuration.\n    @dev\n    Only a project\'s owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project\'s attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle\'s reserved rate in the mint calculation.\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project\'s current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n      if (_reservedRate == 0)\n        // If there\'s no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Burns a token holder\'s supply.\n    @dev\n    Only a token\'s holder, a designated operator, or a project\'s terminal can burn it.\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project\'s attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n    @dev\n    This controller should not yet be the project\'s controller.\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project\'s current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n    @dev\n    Only a project\'s owner or a designated operator can migrate it.\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project\'s current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, \'\');\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n    // Get a reference to the project\'s reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project\'s owner as the beneficiary.\n          // If the split has a beneficiary send to the split\'s beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n        // If there\'s an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n    // Configure the funding cycle\'s properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n    return _fundingCycle.configuration;\n  }\n  /\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \'@openzeppelin/contracts/utils/introspection/ERC165.sol\';\nimport \'@paulrberg/contracts/math/PRBMath.sol\';\nimport \'./abstract/JBOperatable.sol\';\nimport \'./interfaces/IJBController.sol\';\nimport \'./interfaces/IJBMigratable.sol\';\nimport \'./interfaces/IJBOperatorStore.sol\';\nimport \'./interfaces/IJBPaymentTerminal.sol\';\nimport \'./interfaces/IJBProjects.sol\';\nimport \'./libraries/JBConstants.sol\';\nimport \'./libraries/JBFundingCycleMetadataResolver.sol\';\nimport \'./libraries/JBOperations.sol\';\nimport \'./libraries/JBSplitsGroups.sol\';\n/*\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol\'s rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project\'s token\'s total supply is the amount of tokens that still need to have reserves minted against them.\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n  /\n    @notice\n    Mints ERC-721\'s that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it\'s in terms of.\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it\'s in terms of.\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n  / \n    @notice\n    A project\'s funding cycle for the specified configuration along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle\'s metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n  / \n    @notice\n    A project\'s latest configured funding cycle along with its metadata and the ballot state of the configuration.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle\'s metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  / \n    @notice\n    A project\'s current funding cycle along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle\'s metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  /* \n    @notice\n    A project\'s queued funding cycle along with its metadata.\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle\'s metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n    @dev \n    See {IERC165-supportsInterface}.\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721\'s that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner\'s account, configure a first funding cycle, and set up any splits.\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n    @dev\n    Anyone can deploy a project on an owner\'s behalf.\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project\'s first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n    // Set this contract as the project\'s controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project\'s first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n    // Set this contract as the project\'s controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle\'s ballot.\n    @dev\n    Only a project\'s owner or a designated operator can configure its funding cycles.\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n  /\n    @notice\n    Issues an owner\'s ERC20 JBTokens that\'ll be used when claiming tokens.\n    @dev\n    Deploys a project\'s ERC20 JBToken contract.\n    @dev\n    Only a project\'s owner or operator can issue its token.\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20\'s name.\n    @param _symbol The ERC20\'s symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n  /\n    @notice\n    Swap the current project\'s token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n    @dev\n    Only a project\'s owner or operator can change its token.\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token\'s ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project\'s current funding cycle configuration.\n    @dev\n    Only a project\'s owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project\'s attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle\'s reserved rate in the mint calculation.\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project\'s current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n      if (_reservedRate == 0)\n        // If there\'s no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Burns a token holder\'s supply.\n    @dev\n    Only a token\'s holder, a designated operator, or a project\'s terminal can burn it.\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project\'s attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n    @dev\n    This controller should not yet be the project\'s controller.\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project\'s current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n    @dev\n    Only a project\'s owner or a designated operator can migrate it.\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project\'s current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n    // Get a reference to the project\'s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, \'\');\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n    // Get a reference to the project\'s reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project\'s owner as the beneficiary.\n          // If the split has a beneficiary send to the split\'s beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n        // If there\'s an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n    // Configure the funding cycle\'s properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n    return _fundingCycle.configuration;\n  }\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:08 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';
/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.
  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.
  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();
  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//
  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.
    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;
  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.
    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.
    @dev
    bits 232-255: The currency of amount that a project can distribute.
    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;
  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.
    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.
    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.
    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;
  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//
  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;
  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;
  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;
  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.
    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 
    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.
    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];
    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }
  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.
    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 
    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.
    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];
    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }
  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.
    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.
    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }
  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.
    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.
    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);
    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );
    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }
  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's current funding cycle along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's queued funding cycle along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//
  /**
    @notice
    Indicates if this contract adheres to the specified interface.
    @dev 
    See {IERC165-supportsInterface}.
    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }
  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//
  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }
  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//
  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.
    @dev
    Each operation within this transaction can be done in sequence separately.
    @dev
    Anyone can deploy a project on an owner's behalf.
    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.
    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);
    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));
    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);
    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }
  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.
    @dev
    Each operation within this transaction can be done in sequence separately.
    @dev
    Only a project owner or operator can launch its funding cycles.
    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.
    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();
    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));
    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);
    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }
  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.
    @dev
    Only a project's owner or a designated operator can configure its funding cycles.
    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.
    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }
  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.
    @dev
    Deploys a project's ERC20 JBToken contract.
    @dev
    Only a project's owner or operator can issue its token.
    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }
  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.
    @dev
    Only a project's owner or operator can change its token.
    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();
    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }
  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.
    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.
    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.
    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();
    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;
    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );
      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );
      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);
      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }
    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
  /**
    @notice
    Burns a token holder's supply.
    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.
    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);
    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);
    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }
  /**
    @notice
    Distributes all outstanding reserved tokens for a project.
    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.
    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }
  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.
    @dev
    This controller should not yet be the project's controller.
    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();
    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));
    emit PrepMigration(_projectId, _from, msg.sender);
  }
  /**
    @notice
    Allows a project to migrate from this controller to another.
    @dev
    Only a project's owner or a designated operator can migrate it.
    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();
    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');
    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));
    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));
    emit Migrate(_projectId, _to, msg.sender);
  }
  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//
  /**
    @notice
    Distributes all outstanding reserved tokens for a project.
    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.
    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);
    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );
    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);
    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);
    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );
    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);
    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.
    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.
    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;
    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);
    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];
      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );
      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );
        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );
        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }
      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }
  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.
    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.
    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();
    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();
    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();
    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );
    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);
    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];
      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();
      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();
      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();
      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);
      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);
      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }
    return _fundingCycle.configuration;
  }
  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.
    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.
    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);
    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;
    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;
    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;
import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';
/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.
  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.
  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;
  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();
  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//
  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.
    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;
  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.
    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.
    @dev
    bits 232-255: The currency of amount that a project can distribute.
    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;
  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.
    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.
    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.
    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;
  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//
  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;
  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;
  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;
  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;
  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;
  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//
  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.
    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 
    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.
    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];
    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }
  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.
    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 
    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.
    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];
    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }
  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.
    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.
    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }
  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.
    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.
    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);
    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );
    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }
  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's current funding cycle along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  /** 
    @notice
    A project's queued funding cycle along with its metadata.
    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }
  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//
  /**
    @notice
    Indicates if this contract adheres to the specified interface.
    @dev 
    See {IERC165-supportsInterface}.
    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }
  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//
  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }
  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//
  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.
    @dev
    Each operation within this transaction can be done in sequence separately.
    @dev
    Anyone can deploy a project on an owner's behalf.
    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.
    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);
    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));
    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);
    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }
  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.
    @dev
    Each operation within this transaction can be done in sequence separately.
    @dev
    Only a project owner or operator can launch its funding cycles.
    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.
    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();
    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));
    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);
    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }
  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.
    @dev
    Only a project's owner or a designated operator can configure its funding cycles.
    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.
    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );
    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }
  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.
    @dev
    Deploys a project's ERC20 JBToken contract.
    @dev
    Only a project's owner or operator can issue its token.
    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }
  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.
    @dev
    Only a project's owner or operator can change its token.
    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();
    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }
  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.
    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.
    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.
    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();
    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;
    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );
      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );
      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);
      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }
    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }
  /**
    @notice
    Burns a token holder's supply.
    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.
    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);
    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);
    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }
  /**
    @notice
    Distributes all outstanding reserved tokens for a project.
    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.
    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }
  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.
    @dev
    This controller should not yet be the project's controller.
    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();
    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));
    emit PrepMigration(_projectId, _from, msg.sender);
  }
  /**
    @notice
    Allows a project to migrate from this controller to another.
    @dev
    Only a project's owner or a designated operator can migrate it.
    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();
    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');
    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));
    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));
    emit Migrate(_projectId, _to, msg.sender);
  }
  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//
  /**
    @notice
    Distributes all outstanding reserved tokens for a project.
    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.
    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);
    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);
    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );
    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);
    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);
    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );
    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);
    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }
  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.
    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.
    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;
    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);
    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];
      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );
      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );
        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );
        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }
      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }
  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.
    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.
    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();
    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();
    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();
    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );
    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);
    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];
      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();
      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();
      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();
      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);
      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);
      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }
    return _fundingCycle.configuration;
  }
  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.
    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.
    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);
    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;
    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;
    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-01-09 17:02:12 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:12 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27850
completion_tokens: 1
total_tokens: 27851
cost: $-1.000000


[2024-01-09 17:02:12 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Security

[2024-01-09 17:02:12 INFO] **[Seminar Conclusion]**:

 Security

[2024-01-09 17:02:12 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-01-09 17:02:12 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:02:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  / \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /* \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.\n          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there's an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle's properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:02:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18521
completion_tokens: 1
total_tokens: 18522
cost: $-1.000000


[2024-01-09 17:02:15 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

###

[2024-01-09 17:02:15 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:02:15 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-01-09 17:02:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:15 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:02:26 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:26 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9320
completion_tokens: 849
total_tokens: 10169
cost: $-1.000000


[2024-01-09 17:02:26 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Based on the provided Solidity smart contract code for the `JBController` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**:
   - The contract does not implement any reentrancy guards. Functions that involve external calls, such as token minting and burning, could be susceptible to reentrancy attacks if not properly managed.

2. **Access Control Issues**:
   - While the contract uses permission checks for certain functions, there may be edge cases where unauthorized users could exploit functions if the access control logic is not thoroughly validated.
   - The use of `requirePermission` and similar checks should be audited to ensure they cover all scenarios and do not allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any manual arithmetic operations should still be reviewed to ensure they are safe and do not lead to unexpected behavior.

4. **Gas Limit and Loops**:
   - Functions that involve loops, such as `_distributeToReservedTokenSplitsOf`, could run into gas limit issues if the number of splits is large. This could lead to failed transactions or denial of service.

5. **Improper Error Handling**:
   - The contract uses custom errors, which is a good practice, but it should ensure that all potential failure points are covered with appropriate error messages to aid in debugging and user feedback.

6. **Migration Logic**:
   - The migration logic in the `migrate` function should be carefully reviewed to ensure that it correctly handles the state transition and does not leave the contract in an inconsistent state.

7. **Token Minting Logic**:
   - The minting logic in `mintTokensOf` should ensure that it does not allow excessive minting beyond the intended limits, especially in scenarios where the reserved rate is involved.

8. **Event Emission**:
   - Ensure that all state-changing functions emit appropriate events to maintain transparency and allow for easier tracking of contract activity.

### Comprehensive Analysis Report:

The `JBController` contract is designed to manage funding cycles and community tokens, incorporating various functionalities such as project creation, funding cycle management, and token minting. While the contract leverages established libraries and patterns, several security vulnerabilities have been identified that could pose risks to the integrity and functionality of the contract.

1. **Reentrancy**: The absence of reentrancy guards in critical functions could allow malicious actors to exploit the contract by recursively calling functions that alter state, leading to unexpected outcomes.

2. **Access Control**: Although the contract implements permission checks, a thorough review is necessary to ensure that all functions are adequately protected against unauthorized access, particularly in scenarios involving sensitive operations.

3. **Arithmetic Operations**: While Solidity's built-in checks mitigate overflow and underflow risks, careful attention should be paid to manual arithmetic operations to prevent logical errors.

4. **Gas Limit Concerns**: Functions that involve looping through arrays or mappings should be optimized to prevent gas limit issues, which could render the contract unusable under certain conditions.

5. **Error Handling**: The contract should ensure comprehensive error handling to provide clear feedback in case of failures, aiding in debugging and improving user experience.

6. **Migration and State Management**: The migration process must be robust to prevent inconsistencies during state transitions, ensuring that the contract remains functional and secure throughout the process.

7. **Token Minting Safeguards**: The minting logic should enforce strict limits to prevent excessive token creation, particularly in scenarios where reserved rates are involved.

8. **Event Logging**: Adequate event emissions are crucial for transparency and tracking, and all state-changing functions should emit relevant events.

In conclusion, while the `JBController` contract is built on a solid foundation, addressing the identified vulnerabilities is essential to enhance its security posture. A thorough audit of the access control mechanisms, reentrancy protections, and gas efficiency will be critical in ensuring the contract's reliability and safety in a production environment. Regular updates and adherence to best practices in Solidity development will further mitigate risks and enhance the contract's robustness.

[2024-01-09 17:02:26 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `JBController` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risks**:
   - The contract does not implement any reentrancy guards. Functions that involve external calls, such as token minting and burning, could be susceptible to reentrancy attacks if not properly managed.

2. **Access Control Issues**:
   - While the contract uses permission checks for certain functions, there may be edge cases where unauthorized users could exploit functions if the access control logic is not thoroughly validated.
   - The use of `requirePermission` and similar checks should be audited to ensure they cover all scenarios and do not allow unauthorized access.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any manual arithmetic operations should still be reviewed to ensure they are safe and do not lead to unexpected behavior.

4. **Gas Limit and Loops**:
   - Functions that involve loops, such as `_distributeToReservedTokenSplitsOf`, could run into gas limit issues if the number of splits is large. This could lead to failed transactions or denial of service.

5. **Improper Error Handling**:
   - The contract uses custom errors, which is a good practice, but it should ensure that all potential failure points are covered with appropriate error messages to aid in debugging and user feedback.

6. **Migration Logic**:
   - The migration logic in the `migrate` function should be carefully reviewed to ensure that it correctly handles the state transition and does not leave the contract in an inconsistent state.

7. **Token Minting Logic**:
   - The minting logic in `mintTokensOf` should ensure that it does not allow excessive minting beyond the intended limits, especially in scenarios where the reserved rate is involved.

8. **Event Emission**:
   - Ensure that all state-changing functions emit appropriate events to maintain transparency and allow for easier tracking of contract activity.

### Comprehensive Analysis Report:

The `JBController` contract is designed to manage funding cycles and community tokens, incorporating various functionalities such as project creation, funding cycle management, and token minting. While the contract leverages established libraries and patterns, several security vulnerabilities have been identified that could pose risks to the integrity and functionality of the contract.

1. **Reentrancy**: The absence of reentrancy guards in critical functions could allow malicious actors to exploit the contract by recursively calling functions that alter state, leading to unexpected outcomes.

2. **Access Control**: Although the contract implements permission checks, a thorough review is necessary to ensure that all functions are adequately protected against unauthorized access, particularly in scenarios involving sensitive operations.

3. **Arithmetic Operations**: While Solidity's built-in checks mitigate overflow and underflow risks, careful attention should be paid to manual arithmetic operations to prevent logical errors.

4. **Gas Limit Concerns**: Functions that involve looping through arrays or mappings should be optimized to prevent gas limit issues, which could render the contract unusable under certain conditions.

5. **Error Handling**: The contract should ensure comprehensive error handling to provide clear feedback in case of failures, aiding in debugging and improving user experience.

6. **Migration and State Management**: The migration process must be robust to prevent inconsistencies during state transitions, ensuring that the contract remains functional and secure throughout the process.

7. **Token Minting Safeguards**: The minting logic should enforce strict limits to prevent excessive token creation, particularly in scenarios where reserved rates are involved.

8. **Event Logging**: Adequate event emissions are crucial for transparency and tracking, and all state-changing functions should emit relevant events.

In conclusion, while the `JBController` contract is built on a solid foundation, addressing the identified vulnerabilities is essential to enhance its security posture. A thorough audit of the access control mechanisms, reentrancy protections, and gas efficiency will be critical in ensuring the contract's reliability and safety in a production environment. Regular updates and adherence to best practices in Solidity development will further mitigate risks and enhance the contract's robustness.

[2024-01-09 17:02:26 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:02:26 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  / \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /* \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.\n          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there's an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle's properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:26 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:26 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:02:29 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:29 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18521
completion_tokens: 1
total_tokens: 18522
cost: $-1.000000


[2024-01-09 17:02:29 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

###

[2024-01-09 17:02:29 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:02:29 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-01-09 17:02:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:29 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:02:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9320
completion_tokens: 766
total_tokens: 10086
cost: $-1.000000


[2024-01-09 17:02:38 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Based on the provided Solidity smart contract code for the `JBController`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Access Control Issues**:
   - The contract relies on permissions for critical functions (e.g., `launchProjectFor`, `launchFundingCyclesFor`, `mintTokensOf`, etc.). If the access control mechanisms (like `requirePermission`) are not implemented correctly or are bypassed, unauthorized users could execute sensitive functions.

2. **Reentrancy Vulnerability**:
   - Functions that involve external calls (like token minting and burning) could be susceptible to reentrancy attacks if not properly guarded. Although there are no direct calls to external contracts in the provided code, any future modifications or interactions with external contracts could introduce this risk.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that manipulate token amounts should be carefully reviewed to ensure they do not lead to unexpected behaviors, especially when dealing with user balances.

4. **Improper Error Handling**:
   - The contract uses custom errors for various conditions. If these errors are not handled properly in the calling contracts or front-end applications, it could lead to a poor user experience or unintended consequences.

5. **Gas Limit Issues**:
   - Functions that involve loops (e.g., distributing tokens to splits) could run into gas limit issues if the number of splits is large. This could lead to failed transactions or require users to manually manage gas limits.

6. **Lack of Input Validation**:
   - Certain parameters (like `_reservedRate`, `_distributionLimit`, etc.) are checked against constants, but additional validation might be necessary to ensure that they fall within acceptable ranges and do not lead to unexpected behaviors.

7. **Migration Logic**:
   - The migration logic (`migrate` function) assumes that all reserved tokens are minted before migration. If this condition is not met, it could lead to inconsistencies in token distribution and ownership.

8. **Potential Denial of Service (DoS)**:
   - If a function relies on external contracts (like `IJBPaymentTerminal`), and those contracts are not functioning correctly, it could lead to a denial of service where users cannot execute important functions.

### Comprehensive Analysis Report

The `JBController` contract is designed to manage funding cycles and token distributions for projects. While the contract incorporates several best practices, including the use of OpenZeppelin's libraries and custom error handling, it is not without its vulnerabilities.

The primary concerns revolve around access control, which is critical in a decentralized environment where unauthorized access could lead to significant financial losses. The reliance on external contracts for certain functionalities introduces potential risks, particularly if those contracts are not secure or are subject to changes.

Moreover, the contract's logic for handling tokens, especially during minting and burning, must be scrutinized to prevent reentrancy attacks and ensure that all arithmetic operations are safe from overflow or underflow issues.

To mitigate these vulnerabilities, it is recommended to:
- Implement comprehensive testing, including unit tests and integration tests, to ensure that all functions behave as expected under various scenarios.
- Conduct a thorough review of the access control mechanisms to ensure that only authorized users can execute sensitive functions.
- Consider using reentrancy guards on functions that involve external calls.
- Validate all inputs rigorously to prevent unexpected behaviors.
- Monitor gas usage in functions that involve loops to avoid transaction failures.

In conclusion, while the `JBController` contract has a solid foundation, addressing the identified vulnerabilities is essential to ensure its security and reliability in a production environment. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security practices and potential threats.

[2024-01-09 17:02:38 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `JBController`, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Access Control Issues**:
   - The contract relies on permissions for critical functions (e.g., `launchProjectFor`, `launchFundingCyclesFor`, `mintTokensOf`, etc.). If the access control mechanisms (like `requirePermission`) are not implemented correctly or are bypassed, unauthorized users could execute sensitive functions.

2. **Reentrancy Vulnerability**:
   - Functions that involve external calls (like token minting and burning) could be susceptible to reentrancy attacks if not properly guarded. Although there are no direct calls to external contracts in the provided code, any future modifications or interactions with external contracts could introduce this risk.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that manipulate token amounts should be carefully reviewed to ensure they do not lead to unexpected behaviors, especially when dealing with user balances.

4. **Improper Error Handling**:
   - The contract uses custom errors for various conditions. If these errors are not handled properly in the calling contracts or front-end applications, it could lead to a poor user experience or unintended consequences.

5. **Gas Limit Issues**:
   - Functions that involve loops (e.g., distributing tokens to splits) could run into gas limit issues if the number of splits is large. This could lead to failed transactions or require users to manually manage gas limits.

6. **Lack of Input Validation**:
   - Certain parameters (like `_reservedRate`, `_distributionLimit`, etc.) are checked against constants, but additional validation might be necessary to ensure that they fall within acceptable ranges and do not lead to unexpected behaviors.

7. **Migration Logic**:
   - The migration logic (`migrate` function) assumes that all reserved tokens are minted before migration. If this condition is not met, it could lead to inconsistencies in token distribution and ownership.

8. **Potential Denial of Service (DoS)**:
   - If a function relies on external contracts (like `IJBPaymentTerminal`), and those contracts are not functioning correctly, it could lead to a denial of service where users cannot execute important functions.

### Comprehensive Analysis Report

The `JBController` contract is designed to manage funding cycles and token distributions for projects. While the contract incorporates several best practices, including the use of OpenZeppelin's libraries and custom error handling, it is not without its vulnerabilities.

The primary concerns revolve around access control, which is critical in a decentralized environment where unauthorized access could lead to significant financial losses. The reliance on external contracts for certain functionalities introduces potential risks, particularly if those contracts are not secure or are subject to changes.

Moreover, the contract's logic for handling tokens, especially during minting and burning, must be scrutinized to prevent reentrancy attacks and ensure that all arithmetic operations are safe from overflow or underflow issues.

To mitigate these vulnerabilities, it is recommended to:
- Implement comprehensive testing, including unit tests and integration tests, to ensure that all functions behave as expected under various scenarios.
- Conduct a thorough review of the access control mechanisms to ensure that only authorized users can execute sensitive functions.
- Consider using reentrancy guards on functions that involve external calls.
- Validate all inputs rigorously to prevent unexpected behaviors.
- Monitor gas usage in functions that involve loops to avoid transaction failures.

In conclusion, while the `JBController` contract has a solid foundation, addressing the identified vulnerabilities is essential to ensure its security and reliability in a production environment. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security practices and potential threats.

[2024-01-09 17:02:38 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:02:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  / \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /* \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.\n          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there's an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle's properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-01-09 17:02:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18521
completion_tokens: 1
total_tokens: 18522
cost: $-1.000000


[2024-01-09 17:02:41 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

###

[2024-01-09 17:02:41 INFO] **[Seminar Conclusion]**:

 ###

[2024-01-09 17:02:41 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-01-09 17:02:41 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-01-09 17:02:41 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:41 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-01-09 17:02:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-01-09 17:02:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9320
completion_tokens: 673
total_tokens: 9993
cost: $-1.000000


[2024-01-09 17:02:49 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

### Summary of Security Vulnerabilities in the Contract Code

1. **Reentrancy Vulnerabilities**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that modify state variables and make external calls, potentially leading to unexpected behavior or loss of funds.

2. **Access Control Issues**:
   - Certain functions, such as `launchFundingCyclesFor`, `issueTokenFor`, and `changeTokenOf`, rely on permission checks that may not be adequately enforced. If an unauthorized user gains access, they could manipulate project funding cycles or token issuance.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow protection, there are still areas where calculations could lead to unexpected results if not handled properly, particularly in functions that manipulate token amounts.

4. **Improper Error Handling**:
   - The contract uses custom error messages, but there may be scenarios where reverting with a generic error could lead to confusion. More descriptive error handling could improve clarity and debugging.

5. **Gas Limit and Loops**:
   - Functions that involve loops, such as `_distributeToReservedTokenSplitsOf`, could run into gas limit issues if the number of splits is large. This could lead to failed transactions or denial of service.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly, such as checking for zero values where they are not allowed. This could lead to unexpected behavior or state changes.

7. **Migration Risks**:
   - The migration functions (`prepForMigrationOf` and `migrate`) do not adequately check the state of the project before allowing migration, which could lead to inconsistencies if the project is not in a valid state for migration.

8. **Token Minting and Burning Logic**:
   - The logic for minting and burning tokens could be exploited if not properly controlled, especially if the conditions for minting are not strictly enforced.

### Comprehensive Analysis Report

The `JBController` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential financial losses and operational failures. The lack of reentrancy guards is particularly concerning, as it opens the door for reentrancy attacks, which have been the cause of significant losses in other smart contracts.

Access control mechanisms need to be robustly implemented to ensure that only authorized users can perform sensitive operations. The reliance on custom error messages, while useful, should be complemented with more descriptive error handling to aid in debugging and clarity.

Although Solidity's built-in protections against integer overflow and underflow are in place, developers should remain vigilant and ensure that all calculations are handled correctly to avoid unexpected results. Additionally, functions that involve loops should be optimized to prevent gas limit issues, which could lead to transaction failures.

Input validation is crucial; functions should check for invalid inputs, such as zero values, to prevent unintended behavior. The migration process should also be scrutinized to ensure that projects are in a valid state before allowing migration to a new controller.

Finally, the logic surrounding token minting and burning must be carefully controlled to prevent unauthorized manipulation of token supply. Overall, a thorough review and enhancement of the contract's security measures are recommended to mitigate these vulnerabilities and ensure the integrity of the contract's operations.

[2024-01-09 17:02:49 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Contract Code

1. **Reentrancy Vulnerabilities**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that modify state variables and make external calls, potentially leading to unexpected behavior or loss of funds.

2. **Access Control Issues**:
   - Certain functions, such as `launchFundingCyclesFor`, `issueTokenFor`, and `changeTokenOf`, rely on permission checks that may not be adequately enforced. If an unauthorized user gains access, they could manipulate project funding cycles or token issuance.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow protection, there are still areas where calculations could lead to unexpected results if not handled properly, particularly in functions that manipulate token amounts.

4. **Improper Error Handling**:
   - The contract uses custom error messages, but there may be scenarios where reverting with a generic error could lead to confusion. More descriptive error handling could improve clarity and debugging.

5. **Gas Limit and Loops**:
   - Functions that involve loops, such as `_distributeToReservedTokenSplitsOf`, could run into gas limit issues if the number of splits is large. This could lead to failed transactions or denial of service.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly, such as checking for zero values where they are not allowed. This could lead to unexpected behavior or state changes.

7. **Migration Risks**:
   - The migration functions (`prepForMigrationOf` and `migrate`) do not adequately check the state of the project before allowing migration, which could lead to inconsistencies if the project is not in a valid state for migration.

8. **Token Minting and Burning Logic**:
   - The logic for minting and burning tokens could be exploited if not properly controlled, especially if the conditions for minting are not strictly enforced.

### Comprehensive Analysis Report

The `JBController` contract exhibits several security vulnerabilities that could be exploited by malicious actors, leading to potential financial losses and operational failures. The lack of reentrancy guards is particularly concerning, as it opens the door for reentrancy attacks, which have been the cause of significant losses in other smart contracts.

Access control mechanisms need to be robustly implemented to ensure that only authorized users can perform sensitive operations. The reliance on custom error messages, while useful, should be complemented with more descriptive error handling to aid in debugging and clarity.

Although Solidity's built-in protections against integer overflow and underflow are in place, developers should remain vigilant and ensure that all calculations are handled correctly to avoid unexpected results. Additionally, functions that involve loops should be optimized to prevent gas limit issues, which could lead to transaction failures.

Input validation is crucial; functions should check for invalid inputs, such as zero values, to prevent unintended behavior. The migration process should also be scrutinized to ensure that projects are in a valid state before allowing migration to a new controller.

Finally, the logic surrounding token minting and burning must be carefully controlled to prevent unauthorized manipulation of token supply. Overall, a thorough review and enhancement of the contract's security measures are recommended to mitigate these vulnerabilities and ensure the integrity of the contract's operations.

[2024-01-09 17:02:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport './abstract/JBOperatable.sol';\nimport './interfaces/IJBController.sol';\nimport './interfaces/IJBMigratable.sol';\nimport './interfaces/IJBOperatorStore.sol';\nimport './interfaces/IJBPaymentTerminal.sol';\nimport './interfaces/IJBProjects.sol';\nimport './libraries/JBConstants.sol';\nimport './libraries/JBFundingCycleMetadataResolver.sol';\nimport './libraries/JBOperations.sol';\nimport './libraries/JBSplitsGroups.sol';\n\n/\n  @notice\n  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.\n\n  @dev\n  Adheres to -\n  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.\n  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.\n\n  @dev\n  Inherits from -\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\n  ERC165: Introspection on interface adherance. \n/\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n  // A library that parses the packed funding cycle metadata into a more friendly format.\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  //*********//\n  // --------------------------- custom errors ------------------------- //\n  //*********//\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  //*********//\n  // --------------------- internal stored properties ------------------ //\n  //*********//\n\n  /\n    @notice\n    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.\n\n    _projectId The ID of the project to get the tracker of.\n  /\n  mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf;\n\n  /\n    @notice\n    Data regarding the distribution limit of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of token that a project can distribute per funding cycle.\n\n    @dev\n    bits 232-255: The currency of amount that a project can distribute.\n\n    _projectId The ID of the project to get the packed distribution limit data of.\n    _configuration The configuration during which the packed distribution limit data applies.\n    _terminal The terminal from which distributions are being limited.\n    _token The token for which distributions are being limited.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedDistributionLimitDataOf;\n\n  /\n    @notice\n    Data regarding the overflow allowance of a project during a configuration.\n\n    @dev\n    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.\n\n    @dev\n    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.\n\n    _projectId The ID of the project to get the packed overflow allowance data of.\n    _configuration The configuration during which the packed overflow allowance data applies.\n    _terminal The terminal managing the overflow.\n    _token The token for which overflow is being allowed.\n  /\n  mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n  //***********//\n  // --------------- public immutable stored properties ---------------- //\n  //**********//\n\n  /\n    @notice\n    Mints ERC-721's that represent project ownership.\n  /\n  IJBProjects public immutable override projects;\n\n  /\n    @notice\n    The contract storing all funding cycle configurations.\n  /\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  /\n    @notice\n    The contract that manages token minting and burning.\n  /\n  IJBTokenStore public immutable override tokenStore;\n\n  /\n    @notice\n    The contract that stores splits for each project.\n  /\n  IJBSplitsStore public immutable override splitsStore;\n\n  /*\n    @notice\n    The directory of terminals and controllers for projects.\n  /\n  IJBDirectory public immutable override directory;\n\n  //*********//\n  // ------------------------- external views -------------------------- //\n  //*********//\n\n  /\n    @notice\n    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the distribution limit of.\n    @param _configuration The configuration during which the distribution limit applies.\n    @param _terminal The terminal from which distributions are being limited.\n    @param _token The token for which the distribution limit applies.\n\n    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the distribution limit.\n  /\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.\n\n    @dev\n    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. \n\n    @param _projectId The ID of the project to get the overflow allowance of.\n    @param _configuration The configuration of the during which the allowance applies.\n    @param _terminal The terminal managing the overflow.\n    @param _token The token for which the overflow allowance applies.\n\n    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.\n    @return The currency of the overflow allowance.\n  /\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data &gt;&gt; 232);\n  }\n\n  /\n    @notice\n    Gets the amount of reserved tokens that a project has available to distribute.\n\n    @param _projectId The ID of the project to get a reserved token balance of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current amount of reserved tokens.\n  /\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n  /\n    @notice\n    Gets the current total amount of outstanding tokens for a project, given a reserved rate.\n\n    @param _projectId The ID of the project to get total outstanding tokens of.\n    @param _reservedRate The reserved rate to use when making the calculation.\n\n    @return The current total amount of outstanding tokens for the project.\n  /\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  / \n    @notice\n    A project's funding cycle for the specified configuration along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The funding cycle.\n    @return metadata The funding cycle's metadata.\n  */\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The latest configured funding cycle.\n    @return metadata The latest configured funding cycle's metadata.\n    @return ballotState The state of the configuration.\n  /\n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  / \n    @notice\n    A project's current funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The current funding cycle.\n    @return metadata The current funding cycle's metadata.\n  /\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  /* \n    @notice\n    A project's queued funding cycle along with its metadata.\n\n    @param _projectId The ID of the project to which the funding cycle belongs.\n  \n    @return fundingCycle The queued funding cycle.\n    @return metadata The queued funding cycle's metadata.\n  /\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  //*********//\n  // -------------------------- public views --------------------------- //\n  //*********//\n\n  /\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  /\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //**********//\n  // ---------------------------- constructor -------------------------- //\n  //*********//\n\n  /\n    @param _operatorStore A contract storing operator assignments.\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\n    @param _directory A contract storing directories of terminals and controllers for each project.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n    @param _tokenStore A contract that manages token minting and burning.\n    @param _splitsStore A contract that stores splits for each project.\n  /\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  //**********//\n  // --------------------- external transactions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Anyone can deploy a project on an owner's behalf.\n\n    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.\n    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return projectId The ID of the project.\n  /\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Creates a funding cycle for an already existing project ERC-721.\n\n    @dev\n    Each operation within this transaction can be done in sequence separately.\n\n    @dev\n    Only a project owner or operator can launch its funding cycles.\n\n    @param _projectId The ID of the project to launch funding cycles for.\n    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _terminals Payment terminals to add for the project.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully created.\n  /\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project's controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.\n\n    @dev\n    Only a project's owner or a designated operator can configure its funding cycles.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The _distributionLimit and _overflowAllowance parameters must fit in a uint232.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.\n\n    @dev\n    Deploys a project's ERC20 JBToken contract.\n\n    @dev\n    Only a project's owner or operator can issue its token.\n\n    @param _projectId The ID of the project being issued tokens.\n    @param _name The ERC20's name.\n    @param _symbol The ERC20's symbol.\n  /\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n  /\n    @notice\n    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.\n\n    @dev\n    Only a project's owner or operator can change its token.\n\n    @param _projectId The ID of the project to which the changed token belongs.\n    @param _token The new token.\n    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.\n  */\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n  /\n    @notice\n    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.\n\n    @dev\n    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.\n\n    @param _projectId The ID of the project to which the tokens being minted belong.\n    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.\n    @param _beneficiary The account that the tokens are being minted for.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.\n    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.\n\n    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.\n  /\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. _fundingCycle only used within scope.\n    {\n      // Get a reference to the project's current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &amp;&amp;\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there's no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Burns a token holder's supply.\n\n    @dev\n    Only a token's holder, a designated operator, or a project's terminal can burn it.\n\n    @param _holder The account that is having its tokens burned.\n    @param _projectId The ID of the project to which the tokens being burned belong.\n    @param _tokenCount The number of tokens to burn.\n    @param _memo A memo to pass along to the emitted event.\n    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.\n  /\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &amp;&amp;\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return The amount of minted reserved tokens.\n  */\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  /\n    @notice\n    Allows other controllers to signal to this one that a migration is expected for the specified project.\n\n    @dev\n    This controller should not yet be the project's controller.\n\n    @param _projectId The ID of the project that will be migrated to this controller.\n    @param _from The controller being migrated from.\n  /\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project's current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  /\n    @notice\n    Allows a project to migrate from this controller to another.\n\n    @dev\n    Only a project's owner or a designated operator can migrate it.\n\n    @param _projectId The ID of the project that will be migrated from this controller.\n    @param _to The controller to which the project is migrating.\n  /\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project's current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project's current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, '');\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n  //*********//\n  // ------------------------ internal functions ----------------------- //\n  //*********//\n\n  /\n    @notice\n    Distributes all outstanding reserved tokens for a project.\n\n    @param _projectId The ID of the project to which the reserved tokens belong.\n    @param _memo A memo to pass along to the emitted event.\n\n    @return tokenCount The amount of minted reserved tokens.\n  /\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  /\n    @notice\n    Distribute tokens to the splits according to the specified funding cycle configuration.\n\n    @param _projectId The ID of the project for which reserved token splits are being distributed.\n    @param _domain The domain of the splits to distribute the reserved tokens between.\n    @param _group The group of the splits to distribute the reserved tokens between.\n    @param _amount The total amount of tokens to mint.\n\n    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.\n  /\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project's reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i &lt; _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount &gt; 0) {\n        tokenStore.mintFor(\n          // If an allocator is set in the splits, set it as the beneficiary.\n          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.\n          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there's an allocator set, trigger its allocate function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n  /\n    @notice\n    Configures a funding cycle and stores information pertinent to the configuration.\n\n    @param _projectId The ID of the project whose funding cycles are being reconfigured.\n    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.\n    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.\n    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.\n    @param _groupedSplits An array of splits to set for any number of groups. \n    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.\n\n    @return configuration The configuration of the funding cycle that was successfully reconfigured.\n  /\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle's properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency &gt; type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit &gt; 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency &lt;&lt; 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance &gt; 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency &lt;&lt; 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  /*\n    @notice\n    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.\n\n    @param _processedTokenTracker The tracker to make the calculation with.\n    @param _reservedRate The reserved rate to use to make the calculation.\n    @param _totalEligibleTokens The total amount to make the calculation with.\n\n    @return amount reserved token amount.\n  /\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n    // Get a reference to the amount of tokens that are unprocessed.\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n    // If there are no unprocessed tokens, return.\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    // If all tokens are reserved, return the full unprocessed amount.\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-01-09 17:02:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.6; import '@openzeppelin/contracts/utils/introspection/ERC165.sol'; import '@paulrberg/contracts/math/PRBMath.sol'; import './abstract/JBOperatable.sol'; import './interfaces/IJBController.sol'; import './interfaces/IJBMigratable.sol'; import './interfaces/IJBOperatorStore.sol'; import './interfaces/IJBPaymentTerminal.sol'; import './interfaces/IJBProjects.sol'; import './libraries/JBConstants.sol'; import './libraries/JBFundingCycleMetadataResolver.sol'; import './libraries/JBOperations.sol'; import './libraries/JBSplitsGroups.sol'; /**   @notice   Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct. @dev   Adheres to -   IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.   IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration. @dev   Inherits from -   JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.   ERC165: Introspection on interface adherance.  */ contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {   // A library that parses the packed funding cycle metadata into a more friendly format.   using JBFundingCycleMetadataResolver for JBFundingCycle; //***********//   // --------------------------- custom errors ------------------------- //   //*************//   error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();   error CANT_MIGRATE_TO_CURRENT_CONTROLLER();   error CHANGE_TOKEN_NOT_ALLOWED();   error FUNDING_CYCLE_ALREADY_LAUNCHED();   error INVALID_BALLOT_REDEMPTION_RATE();   error INVALID_DISTRIBUTION_LIMIT();   error INVALID_DISTRIBUTION_LIMIT_CURRENCY();   error INVALID_OVERFLOW_ALLOWANCE();   error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();   error INVALID_REDEMPTION_RATE();   error INVALID_RESERVED_RATE();   error MIGRATION_NOT_ALLOWED();   error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();   error NO_BURNABLE_TOKENS();   error NOT_CURRENT_CONTROLLER();   error ZERO_TOKENS_TO_MINT(); //***********//   // --------------------- internal stored properties ------------------ //   //*************// /**     @notice     The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them. _projectId The ID of the project to get the tracker of.  */   mapping(uint256 =&gt; int256) internal _processedTokenTrackerOf; /**     @notice     Data regarding the distribution limit of a project during a configuration. @dev bits 0-231: The amount of token that a project can distribute per funding cycle.  @dev bits 232-255: The currency of amount that a project can distribute.  _projectId The ID of the project to get the packed distribution limit data of. _configuration The configuration during which the packed distribution limit data applies. _terminal The terminal from which distributions are being limited. _token The token for which distributions are being limited.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedDistributionLimitDataOf; /**     @notice     Data regarding the overflow allowance of a project during a configuration. @dev bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.  @dev bits 232-255: The currency of the amount of overflow that a project is allowed to tap.  _projectId The ID of the project to get the packed overflow allowance data of. _configuration The configuration during which the packed overflow allowance data applies. _terminal The terminal managing the overflow. _token The token for which overflow is being allowed.  */   mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(IJBPaymentTerminal =&gt; mapping(address =&gt; uint256))))     internal _packedOverflowAllowanceDataOf; //***********//   // --------------- public immutable stored properties ---------------- //   //*************// /*     @notice     Mints ERC-721's that represent project ownership.   /   IJBProjects public immutable override projects; /*     @notice     The contract storing all funding cycle configurations.   /   IJBFundingCycleStore public immutable override fundingCycleStore; /*     @notice     The contract that manages token minting and burning.   /   IJBTokenStore public immutable override tokenStore; /*     @notice     The contract that stores splits for each project.   /   IJBSplitsStore public immutable override splitsStore; /*     @notice     The directory of terminals and controllers for projects.   /   IJBDirectory public immutable override directory; //***********//   // ------------------------- external views -------------------------- //   //*************// /**     @notice     The amount of token that a project can distribute per funding cycle, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the distribution limit of. @param _configuration The configuration during which the distribution limit applies. @param _terminal The terminal from which distributions are being limited. @param _token The token for which the distribution limit applies.  @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the distribution limit.  */   function distributionLimitOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token]; // The limit is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of. @dev The number of decimals in the returned fixed point amount is the same as that of the specified terminal.  @param _projectId The ID of the project to get the overflow allowance of. @param _configuration The configuration of the during which the allowance applies. @param _terminal The terminal managing the overflow. @param _token The token for which the overflow allowance applies.  @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal. @return The currency of the overflow allowance.  */   function overflowAllowanceOf(     uint256 _projectId,     uint256 _configuration,     IJBPaymentTerminal _terminal,     address _token   ) external view override returns (uint256, uint256) {     // Get a reference to the packed data.     uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token]; // The allowance is in bits 0-231. The currency is in bits 232-255. return (uint256(uint232(_data)), _data &gt;&gt; 232);  } /**     @notice     Gets the amount of reserved tokens that a project has available to distribute. @param _projectId The ID of the project to get a reserved token balance of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current amount of reserved tokens.  */   function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     return       _reservedTokenAmountFrom(         _processedTokenTrackerOf[_projectId],         _reservedRate,         tokenStore.totalSupplyOf(_projectId)       );   } /**     @notice     Gets the current total amount of outstanding tokens for a project, given a reserved rate. @param _projectId The ID of the project to get total outstanding tokens of. @param _reservedRate The reserved rate to use when making the calculation.  @return The current total amount of outstanding tokens for the project.  */   function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)     external     view     override     returns (uint256)   {     // Get the total number of tokens in circulation.     uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId); // Get the number of reserved tokens the project has. uint256 _reservedTokenAmount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _reservedRate,   _totalSupply );  // Add the reserved tokens to the total supply. return _totalSupply + _reservedTokenAmount;  } /**      @notice     A project's funding cycle for the specified configuration along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The funding cycle. @return metadata The funding cycle's metadata.  */   function getFundingCycleOf(uint256 _projectId, uint256 _configuration)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.get(_projectId, _configuration);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's latest configured funding cycle along with its metadata and the ballot state of the configuration. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The latest configured funding cycle. @return metadata The latest configured funding cycle's metadata. @return ballotState The state of the configuration.  */   function latestConfiguredFundingCycleOf(uint256 _projectId)     external     view     override     returns (       JBFundingCycle memory fundingCycle,       JBFundingCycleMetadata memory metadata,       JBBallotState ballotState     )   {     (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's current funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The current funding cycle. @return metadata The current funding cycle's metadata.  */   function currentFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.currentOf(_projectId);     metadata = fundingCycle.expandMetadata();   } /**      @notice     A project's queued funding cycle along with its metadata. @param _projectId The ID of the project to which the funding cycle belongs.  @return fundingCycle The queued funding cycle. @return metadata The queued funding cycle's metadata.  */   function queuedFundingCycleOf(uint256 _projectId)     external     view     override     returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)   {     fundingCycle = fundingCycleStore.queuedOf(_projectId);     metadata = fundingCycle.expandMetadata();   } //***********//   // -------------------------- public views --------------------------- //   //*************// /**     @notice     Indicates if this contract adheres to the specified interface. @dev  See {IERC165-supportsInterface}.  @param _interfaceId The ID of the interface to check for adherance to.  */   function supportsInterface(bytes4 _interfaceId)     public     view     virtual     override(ERC165, IERC165)     returns (bool)   {     return       _interfaceId == type(IJBController).interfaceId ||       _interfaceId == type(IJBMigratable).interfaceId ||       _interfaceId == type(IJBOperatable).interfaceId ||       super.supportsInterface(_interfaceId);   } //***********//   // ---------------------------- constructor -------------------------- //   //*************// /*     @param _operatorStore A contract storing operator assignments.     @param _projects A contract which mints ERC-721's that represent project ownership and transfers.     @param _directory A contract storing directories of terminals and controllers for each project.     @param _fundingCycleStore A contract storing all funding cycle configurations.     @param _tokenStore A contract that manages token minting and burning.     @param _splitsStore A contract that stores splits for each project.   /   constructor(     IJBOperatorStore _operatorStore,     IJBProjects _projects,     IJBDirectory _directory,     IJBFundingCycleStore _fundingCycleStore,     IJBTokenStore _tokenStore,     IJBSplitsStore _splitsStore   ) JBOperatable(_operatorStore) {     projects = _projects;     directory = _directory;     fundingCycleStore = _fundingCycleStore;     tokenStore = _tokenStore;     splitsStore = _splitsStore;   } //***********//   // --------------------- external transactions ----------------------- //   //*************// /**     @notice     Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits. @dev Each operation within this transaction can be done in sequence separately.  @dev Anyone can deploy a project on an owner's behalf.  @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address. @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return projectId The ID of the project.  */   function launchProjectFor(     address _owner,     JBProjectMetadata calldata _projectMetadata,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   ) external virtual override returns (uint256 projectId) {     // Mint the project into the wallet of the message sender.     projectId = projects.createFor(_owner, _projectMetadata); // Set this contract as the project's controller in the directory. directory.setControllerOf(projectId, address(this));  // Configure the first funding cycle. uint256 _configuration = _configure(   projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(projectId, _terminals);  emit LaunchProject(_configuration, projectId, _memo, msg.sender);  } /**     @notice     Creates a funding cycle for an already existing project ERC-721. @dev Each operation within this transaction can be done in sequence separately.  @dev Only a project owner or operator can launch its funding cycles.  @param _projectId The ID of the project to launch funding cycles for. @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _terminals Payment terminals to add for the project. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully created.  */   function launchFundingCyclesFor(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints,     IJBPaymentTerminal[] memory _terminals,     string memory _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead     if (fundingCycleStore.latestConfigurationOf(_projectId) &gt; 0)       revert FUNDING_CYCLE_ALREADY_LAUNCHED(); // Set this contract as the project's controller in the directory. directory.setControllerOf(_projectId, address(this));  // Configure the first funding cycle. configuration = _configure(   _projectId,   _data,   _metadata,   _mustStartAtOrAfter,   _groupedSplits,   _fundAccessConstraints );  // Add the provided terminals to the list of terminals. if (_terminals.length &gt; 0) directory.setTerminalsOf(_projectId, _terminals);  emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot. @dev Only a project's owner or a designated operator can configure its funding cycles.  @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`. @param _memo A memo to pass along to the emitted event.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function reconfigureFundingCyclesOf(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] calldata _groupedSplits,     JBFundAccessConstraints[] calldata _fundAccessConstraints,     string calldata _memo   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)     returns (uint256 configuration)   {     // Configure the next funding cycle.     configuration = _configure(       _projectId,       _data,       _metadata,       _mustStartAtOrAfter,       _groupedSplits,       _fundAccessConstraints     ); emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);  } /**     @notice     Issues an owner's ERC20 JBTokens that'll be used when claiming tokens. @dev Deploys a project's ERC20 JBToken contract.  @dev Only a project's owner or operator can issue its token.  @param _projectId The ID of the project being issued tokens. @param _name The ERC20's name. @param _symbol The ERC20's symbol.  */   function issueTokenFor(     uint256 _projectId,     string calldata _name,     string calldata _symbol   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)     returns (IJBToken token)   {     // Issue the token in the store.     return tokenStore.issueFor(_projectId, _name, _symbol);   } /**     @notice     Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed. @dev Only a project's owner or operator can change its token.  @param _projectId The ID of the project to which the changed token belongs. @param _token The new token. @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.  */   function changeTokenOf(     uint256 _projectId,     IJBToken _token,     address _newOwner   )     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)   {     // Get a reference to the project's current funding cycle.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // The current funding cycle must not be paused. if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();  // Change the token in the store. tokenStore.changeFor(_projectId, _token, _newOwner);  } /**     @notice     Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration. @dev Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.  @param _projectId The ID of the project to which the tokens being minted belong. @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved. @param _beneficiary The account that the tokens are being minted for. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued. @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.  @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.  */   function mintTokensOf(     uint256 _projectId,     uint256 _tokenCount,     address _beneficiary,     string calldata _memo,     bool _preferClaimedTokens,     bool _useReservedRate   ) external virtual override returns (uint256 beneficiaryTokenCount) {     // There should be tokens to mint.     if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT(); // Define variables that will be needed outside scoped section below. // Keep a reference to the reserved rate to use uint256 _reservedRate;  // Scoped section prevents stack too deep. `_fundingCycle` only used within scope. {   // Get a reference to the project's current funding cycle.   JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);    // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source   _requirePermissionAllowingOverride(     projects.ownerOf(_projectId),     _projectId,     JBOperations.MINT,     directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||       msg.sender == address(_fundingCycle.dataSource())   );    // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.   if (     !_fundingCycle.mintingAllowed() &amp;&amp;     !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &amp;&amp;     msg.sender != address(_fundingCycle.dataSource())   ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();    // Determine the reserved rate to use.   _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0; }  if (_reservedRate == JBConstants.MAX_RESERVED_RATE)   // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.   _processedTokenTrackerOf[_projectId] =     _processedTokenTrackerOf[_projectId] -     int256(_tokenCount); else {   // The unreserved token count that will be minted for the beneficiary.   beneficiaryTokenCount = PRBMath.mulDiv(     _tokenCount,     JBConstants.MAX_RESERVED_RATE - _reservedRate,     JBConstants.MAX_RESERVED_RATE   );    if (_reservedRate == 0)     // If there's no reserved rate, increment the tracker with the newly minted tokens.     _processedTokenTrackerOf[_projectId] =       _processedTokenTrackerOf[_projectId] +       int256(beneficiaryTokenCount);    // Mint the tokens.   tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens); }  emit MintTokens(   _beneficiary,   _projectId,   _tokenCount,   beneficiaryTokenCount,   _memo,   _reservedRate,   msg.sender );  } /**     @notice     Burns a token holder's supply. @dev Only a token's holder, a designated operator, or a project's terminal can burn it.  @param _holder The account that is having its tokens burned. @param _projectId The ID of the project to which the tokens being burned belong. @param _tokenCount The number of tokens to burn. @param _memo A memo to pass along to the emitted event. @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.  */   function burnTokensOf(     address _holder,     uint256 _projectId,     uint256 _tokenCount,     string calldata _memo,     bool _preferClaimedTokens   )     external     virtual     override     requirePermissionAllowingOverride(       _holder,       _projectId,       JBOperations.BURN,       directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))     )   {     // There should be tokens to burn     if (_tokenCount == 0) revert NO_BURNABLE_TOKENS(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // If the message sender is not a terminal, the current funding cycle must not be paused. if (   _fundingCycle.burnPaused() &amp;&amp;   !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();  // Update the token tracker so that reserved tokens will still be correctly mintable. _processedTokenTrackerOf[_projectId] =   _processedTokenTrackerOf[_projectId] -   int256(_tokenCount);  // Burn the tokens. tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);  emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);  } /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return The amount of minted reserved tokens.  */   function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)     external     virtual     override     returns (uint256)   {     return _distributeReservedTokensOf(_projectId, _memo);   } /**     @notice     Allows other controllers to signal to this one that a migration is expected for the specified project. @dev This controller should not yet be the project's controller.  @param _projectId The ID of the project that will be migrated to this controller. @param _from The controller being migrated from.  */   function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {     // This controller must not be the project's current controller.     if (directory.controllerOf(_projectId) == address(this))       revert CANT_MIGRATE_TO_CURRENT_CONTROLLER(); // Set the tracker as the total supply. _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));  emit PrepMigration(_projectId, _from, msg.sender);  } /**     @notice     Allows a project to migrate from this controller to another. @dev Only a project's owner or a designated operator can migrate it.  @param _projectId The ID of the project that will be migrated from this controller. @param _to The controller to which the project is migrating.  */   function migrate(uint256 _projectId, IJBMigratable _to)     external     virtual     override     requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)   {     // This controller must be the project's current controller.     if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER(); // Get a reference to the project's current funding cycle. JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);  // Migration must be allowed. if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();  // All reserved tokens must be minted before migrating. if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))   _distributeReservedTokensOf(_projectId, '');  // Make sure the new controller is prepped for the migration. _to.prepForMigrationOf(_projectId, address(this));  // Set the new controller. directory.setControllerOf(_projectId, address(_to));  emit Migrate(_projectId, _to, msg.sender);  } //***********//   // ------------------------ internal functions ----------------------- //   //*************// /**     @notice     Distributes all outstanding reserved tokens for a project. @param _projectId The ID of the project to which the reserved tokens belong. @param _memo A memo to pass along to the emitted event.  @return tokenCount The amount of minted reserved tokens.  */   function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)     internal     returns (uint256 tokenCount)   {     // Get the current funding cycle to read the reserved rate from.     JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId); // Get a reference to new total supply of tokens before minting reserved tokens. uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);  // Get a reference to the number of tokens that need to be minted. tokenCount = _reservedTokenAmountFrom(   _processedTokenTrackerOf[_projectId],   _fundingCycle.reservedRate(),   _totalTokens );  // Set the tracker to be the new total supply. _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);  // Get a reference to the project owner. address _owner = projects.ownerOf(_projectId);  // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share. uint256 _leftoverTokenCount = tokenCount == 0   ? 0   : _distributeToReservedTokenSplitsOf(     _projectId,     _fundingCycle.configuration,     JBSplitsGroups.RESERVED_TOKENS,     tokenCount   );  // Mint any leftover tokens to the project owner. if (_leftoverTokenCount &gt; 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);  emit DistributeReservedTokens(   _fundingCycle.configuration,   _fundingCycle.number,   _projectId,   _owner,   tokenCount,   _leftoverTokenCount,   _memo,   msg.sender );  } /**     @notice     Distribute tokens to the splits according to the specified funding cycle configuration. @param _projectId The ID of the project for which reserved token splits are being distributed. @param _domain The domain of the splits to distribute the reserved tokens between. @param _group The group of the splits to distribute the reserved tokens between. @param _amount The total amount of tokens to mint.  @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.  */   function _distributeToReservedTokenSplitsOf(     uint256 _projectId,     uint256 _domain,     uint256 _group,     uint256 _amount   ) internal returns (uint256 leftoverAmount) {     // Set the leftover amount to the initial amount.     leftoverAmount = _amount; // Get a reference to the project's reserved token splits. JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);  //Transfer between all splits. for (uint256 _i = 0; _i &lt; _splits.length; _i++) {   // Get a reference to the split being iterated on.   JBSplit memory _split = _splits[_i];    // The amount to send towards the split.   uint256 _tokenCount = PRBMath.mulDiv(     _amount,     _split.percent,     JBConstants.SPLITS_TOTAL_PERCENT   );    // Mints tokens for the split if needed.   if (_tokenCount &gt; 0) {     tokenStore.mintFor(       // If an allocator is set in the splits, set it as the beneficiary.       // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.       // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.       _split.allocator != IJBSplitAllocator(address(0))         ? address(_split.allocator)         : _split.projectId != 0         ? projects.ownerOf(_split.projectId)         : _split.beneficiary != address(0)         ? _split.beneficiary         : msg.sender,       _projectId,       _tokenCount,       _split.preferClaimed     );      // If there's an allocator set, trigger its `allocate` function.     if (_split.allocator != IJBSplitAllocator(address(0)))       _split.allocator.allocate(         JBSplitAllocationData(           address(tokenStore.tokenOf(_projectId)),           _tokenCount,           18,           _projectId,           _group,           _split         )       );      // Subtract from the amount to be sent to the beneficiary.     leftoverAmount = leftoverAmount - _tokenCount;   }    emit DistributeToReservedTokenSplit(     _projectId,     _domain,     _group,     _split,     _tokenCount,     msg.sender   ); }  } /**     @notice     Configures a funding cycle and stores information pertinent to the configuration. @param _projectId The ID of the project whose funding cycles are being reconfigured. @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle. @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle. @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start. @param _groupedSplits An array of splits to set for any number of groups.  @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.  @return configuration The configuration of the funding cycle that was successfully reconfigured.  */   function _configure(     uint256 _projectId,     JBFundingCycleData calldata _data,     JBFundingCycleMetadata calldata _metadata,     uint256 _mustStartAtOrAfter,     JBGroupedSplits[] memory _groupedSplits,     JBFundAccessConstraints[] memory _fundAccessConstraints   ) internal returns (uint256) {     // Make sure the provided reserved rate is valid.     if (_metadata.reservedRate &gt; JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE(); // Make sure the provided redemption rate is valid. if (_metadata.redemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_REDEMPTION_RATE();  // Make sure the provided ballot redemption rate is valid. if (_metadata.ballotRedemptionRate &gt; JBConstants.MAX_REDEMPTION_RATE)   revert INVALID_BALLOT_REDEMPTION_RATE();  // Configure the funding cycle's properties. JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(   _projectId,   _data,   JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),   _mustStartAtOrAfter );  // Set splits for the group. splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);  // Set distribution limits if there are any. for (uint256 _i; _i &lt; _fundAccessConstraints.length; _i++) {   JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];    // If distribution limit value is larger than 232 bits, revert.   if (_constraints.distributionLimit &gt; type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();    // If distribution limit currency value is larger than 24 bits, revert.   if (_constraints.distributionLimitCurrency &gt; type(uint24).max)     revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();    // If overflow allowance value is larger than 232 bits, revert.   if (_constraints.overflowAllowance &gt; type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();    // If overflow allowance currency value is larger than 24 bits, revert.   if (_constraints.overflowAllowanceCurrency &gt; type(uint24).max)     revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();    // Set the distribution limit if there is one.   if (_constraints.distributionLimit &gt; 0)     _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.distributionLimit |       (_constraints.distributionLimitCurrency &lt;&lt; 232);    // Set the overflow allowance if there is one.   if (_constraints.overflowAllowance &gt; 0)     _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][       _constraints.terminal     ][_constraints.token] =       _constraints.overflowAllowance |       (_constraints.overflowAllowanceCurrency &lt;&lt; 232);    emit SetFundAccessConstraints(     _fundingCycle.configuration,     _fundingCycle.number,     _projectId,     _constraints,     msg.sender   ); }  return _fundingCycle.configuration;  } /**     @notice     Gets the amount of reserved tokens currently tracked for a project given a reserved rate. @param _processedTokenTracker The tracker to make the calculation with. @param _reservedRate The reserved rate to use to make the calculation. @param _totalEligibleTokens The total amount to make the calculation with.  @return amount reserved token amount.  */   function _reservedTokenAmountFrom(     int256 _processedTokenTracker,     uint256 _reservedRate,     uint256 _totalEligibleTokens   ) internal pure returns (uint256) {     // Get a reference to the amount of tokens that are unprocessed.     uint256 _unprocessedTokenBalanceOf = _processedTokenTracker &gt;= 0       ? _totalEligibleTokens - uint256(_processedTokenTracker)       : _totalEligibleTokens + uint256(-_processedTokenTracker); // If there are no unprocessed tokens, return. if (_unprocessedTokenBalanceOf == 0) return 0;  // If all tokens are reserved, return the full unprocessed amount. if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;  return   PRBMath.mulDiv(     _unprocessedTokenBalanceOf,     JBConstants.MAX_RESERVED_RATE,     JBConstants.MAX_RESERVED_RATE - _reservedRate   ) - _unprocessedTokenBalanceOf;  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-01-09 17:02:53 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import '@openzeppelin/contracts/utils/introspection/ERC165.sol';
import '@paulrberg/contracts/math/PRBMath.sol';
import './abstract/JBOperatable.sol';
import './interfaces/IJBController.sol';
import './interfaces/IJBMigratable.sol';
import './interfaces/IJBOperatorStore.sol';
import './interfaces/IJBPaymentTerminal.sol';
import './interfaces/IJBProjects.sol';
import './libraries/JBConstants.sol';
import './libraries/JBFundingCycleMetadataResolver.sol';
import './libraries/JBOperations.sol';
import './libraries/JBSplitsGroups.sol';

/**
  @notice
  Stitches together funding cycles and community tokens, making sure all activity is accounted for and correct.

  @dev
  Adheres to -
  IJBController: General interface for the generic controller methods in this contract that interacts with funding cycles and tokens according to the protocol's rules.
  IJBMigratable: Allows migrating to this contract, with a hook called to prepare for the migration.

  @dev
  Inherits from -
  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.
  ERC165: Introspection on interface adherance. 
*/
contract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {
  // A library that parses the packed funding cycle metadata into a more friendly format.
  using JBFundingCycleMetadataResolver for JBFundingCycle;

  //*********************************************************************//
  // --------------------------- custom errors ------------------------- //
  //*********************************************************************//
  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();
  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();
  error CHANGE_TOKEN_NOT_ALLOWED();
  error FUNDING_CYCLE_ALREADY_LAUNCHED();
  error INVALID_BALLOT_REDEMPTION_RATE();
  error INVALID_DISTRIBUTION_LIMIT();
  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();
  error INVALID_OVERFLOW_ALLOWANCE();
  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();
  error INVALID_REDEMPTION_RATE();
  error INVALID_RESERVED_RATE();
  error MIGRATION_NOT_ALLOWED();
  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();
  error NO_BURNABLE_TOKENS();
  error NOT_CURRENT_CONTROLLER();
  error ZERO_TOKENS_TO_MINT();

  //*********************************************************************//
  // --------------------- internal stored properties ------------------ //
  //*********************************************************************//

  /**
    @notice
    The difference between the processed token tracker of a project and the project's token's total supply is the amount of tokens that still need to have reserves minted against them.

    _projectId The ID of the project to get the tracker of.
  */
  mapping(uint256 => int256) internal _processedTokenTrackerOf;

  /**
    @notice
    Data regarding the distribution limit of a project during a configuration.

    @dev
    bits 0-231: The amount of token that a project can distribute per funding cycle.

    @dev
    bits 232-255: The currency of amount that a project can distribute.

    _projectId The ID of the project to get the packed distribution limit data of.
    _configuration The configuration during which the packed distribution limit data applies.
    _terminal The terminal from which distributions are being limited.
    _token The token for which distributions are being limited.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedDistributionLimitDataOf;

  /**
    @notice
    Data regarding the overflow allowance of a project during a configuration.

    @dev
    bits 0-231: The amount of overflow that a project is allowed to tap into on-demand throughout the configuration.

    @dev
    bits 232-255: The currency of the amount of overflow that a project is allowed to tap.

    _projectId The ID of the project to get the packed overflow allowance data of.
    _configuration The configuration during which the packed overflow allowance data applies.
    _terminal The terminal managing the overflow.
    _token The token for which overflow is being allowed.
  */
  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))
    internal _packedOverflowAllowanceDataOf;

  //*********************************************************************//
  // --------------- public immutable stored properties ---------------- //
  //*********************************************************************//

  /**
    @notice
    Mints ERC-721's that represent project ownership.
  */
  IJBProjects public immutable override projects;

  /**
    @notice
    The contract storing all funding cycle configurations.
  */
  IJBFundingCycleStore public immutable override fundingCycleStore;

  /**
    @notice
    The contract that manages token minting and burning.
  */
  IJBTokenStore public immutable override tokenStore;

  /**
    @notice
    The contract that stores splits for each project.
  */
  IJBSplitsStore public immutable override splitsStore;

  /**
    @notice
    The directory of terminals and controllers for projects.
  */
  IJBDirectory public immutable override directory;

  //*********************************************************************//
  // ------------------------- external views -------------------------- //
  //*********************************************************************//

  /**
    @notice
    The amount of token that a project can distribute per funding cycle, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the distribution limit of.
    @param _configuration The configuration during which the distribution limit applies.
    @param _terminal The terminal from which distributions are being limited.
    @param _token The token for which the distribution limit applies.

    @return The distribution limit, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the distribution limit.
  */
  function distributionLimitOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];

    // The limit is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    The amount of overflow that a project is allowed to tap into on-demand throughout a configuration, and the currency it's in terms of.

    @dev
    The number of decimals in the returned fixed point amount is the same as that of the specified terminal. 

    @param _projectId The ID of the project to get the overflow allowance of.
    @param _configuration The configuration of the during which the allowance applies.
    @param _terminal The terminal managing the overflow.
    @param _token The token for which the overflow allowance applies.

    @return The overflow allowance, as a fixed point number with the same number of decimals as the provided terminal.
    @return The currency of the overflow allowance.
  */
  function overflowAllowanceOf(
    uint256 _projectId,
    uint256 _configuration,
    IJBPaymentTerminal _terminal,
    address _token
  ) external view override returns (uint256, uint256) {
    // Get a reference to the packed data.
    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];

    // The allowance is in bits 0-231. The currency is in bits 232-255.
    return (uint256(uint232(_data)), _data >> 232);
  }

  /**
    @notice
    Gets the amount of reserved tokens that a project has available to distribute.

    @param _projectId The ID of the project to get a reserved token balance of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current amount of reserved tokens.
  */
  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    return
      _reservedTokenAmountFrom(
        _processedTokenTrackerOf[_projectId],
        _reservedRate,
        tokenStore.totalSupplyOf(_projectId)
      );
  }

  /**
    @notice
    Gets the current total amount of outstanding tokens for a project, given a reserved rate.

    @param _projectId The ID of the project to get total outstanding tokens of.
    @param _reservedRate The reserved rate to use when making the calculation.

    @return The current total amount of outstanding tokens for the project.
  */
  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)
    external
    view
    override
    returns (uint256)
  {
    // Get the total number of tokens in circulation.
    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);

    // Get the number of reserved tokens the project has.
    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _reservedRate,
      _totalSupply
    );

    // Add the reserved tokens to the total supply.
    return _totalSupply + _reservedTokenAmount;
  }

  /** 
    @notice
    A project's funding cycle for the specified configuration along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The funding cycle.
    @return metadata The funding cycle's metadata.
  */
  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.get(_projectId, _configuration);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's latest configured funding cycle along with its metadata and the ballot state of the configuration.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The latest configured funding cycle.
    @return metadata The latest configured funding cycle's metadata.
    @return ballotState The state of the configuration.
  */
  function latestConfiguredFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (
      JBFundingCycle memory fundingCycle,
      JBFundingCycleMetadata memory metadata,
      JBBallotState ballotState
    )
  {
    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's current funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The current funding cycle.
    @return metadata The current funding cycle's metadata.
  */
  function currentFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.currentOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  /** 
    @notice
    A project's queued funding cycle along with its metadata.

    @param _projectId The ID of the project to which the funding cycle belongs.
  
    @return fundingCycle The queued funding cycle.
    @return metadata The queued funding cycle's metadata.
  */
  function queuedFundingCycleOf(uint256 _projectId)
    external
    view
    override
    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)
  {
    fundingCycle = fundingCycleStore.queuedOf(_projectId);
    metadata = fundingCycle.expandMetadata();
  }

  //*********************************************************************//
  // -------------------------- public views --------------------------- //
  //*********************************************************************//

  /**
    @notice
    Indicates if this contract adheres to the specified interface.

    @dev 
    See {IERC165-supportsInterface}.

    @param _interfaceId The ID of the interface to check for adherance to.
  */
  function supportsInterface(bytes4 _interfaceId)
    public
    view
    virtual
    override(ERC165, IERC165)
    returns (bool)
  {
    return
      _interfaceId == type(IJBController).interfaceId ||
      _interfaceId == type(IJBMigratable).interfaceId ||
      _interfaceId == type(IJBOperatable).interfaceId ||
      super.supportsInterface(_interfaceId);
  }

  //*********************************************************************//
  // ---------------------------- constructor -------------------------- //
  //*********************************************************************//

  /**
    @param _operatorStore A contract storing operator assignments.
    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.
    @param _directory A contract storing directories of terminals and controllers for each project.
    @param _fundingCycleStore A contract storing all funding cycle configurations.
    @param _tokenStore A contract that manages token minting and burning.
    @param _splitsStore A contract that stores splits for each project.
  */
  constructor(
    IJBOperatorStore _operatorStore,
    IJBProjects _projects,
    IJBDirectory _directory,
    IJBFundingCycleStore _fundingCycleStore,
    IJBTokenStore _tokenStore,
    IJBSplitsStore _splitsStore
  ) JBOperatable(_operatorStore) {
    projects = _projects;
    directory = _directory;
    fundingCycleStore = _fundingCycleStore;
    tokenStore = _tokenStore;
    splitsStore = _splitsStore;
  }

  //*********************************************************************//
  // --------------------- external transactions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Creates a project. This will mint an ERC-721 into the specified owner's account, configure a first funding cycle, and set up any splits.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Anyone can deploy a project on an owner's behalf.

    @param _owner The address to set as the owner of the project. The project ERC-721 will be owned by this address.
    @param _projectMetadata Metadata to associate with the project within a particular domain. This can be updated any time by the owner of the project.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return projectId The ID of the project.
  */
  function launchProjectFor(
    address _owner,
    JBProjectMetadata calldata _projectMetadata,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  ) external virtual override returns (uint256 projectId) {
    // Mint the project into the wallet of the message sender.
    projectId = projects.createFor(_owner, _projectMetadata);

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(projectId, address(this));

    // Configure the first funding cycle.
    uint256 _configuration = _configure(
      projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);

    emit LaunchProject(_configuration, projectId, _memo, msg.sender);
  }

  /**
    @notice
    Creates a funding cycle for an already existing project ERC-721.

    @dev
    Each operation within this transaction can be done in sequence separately.

    @dev
    Only a project owner or operator can launch its funding cycles.

    @param _projectId The ID of the project to launch funding cycles for.
    @param _data Data that defines the project's first funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _terminals Payment terminals to add for the project.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully created.
  */
  function launchFundingCyclesFor(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints,
    IJBPaymentTerminal[] memory _terminals,
    string memory _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead
    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)
      revert FUNDING_CYCLE_ALREADY_LAUNCHED();

    // Set this contract as the project's controller in the directory.
    directory.setControllerOf(_projectId, address(this));

    // Configure the first funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    // Add the provided terminals to the list of terminals.
    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);

    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Proposes a configuration of a subsequent funding cycle that will take effect once the current one expires if it is approved by the current funding cycle's ballot.

    @dev
    Only a project's owner or a designated operator can configure its funding cycles.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal. The `_distributionLimit` and `_overflowAllowance` parameters must fit in a `uint232`.
    @param _memo A memo to pass along to the emitted event.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function reconfigureFundingCyclesOf(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] calldata _groupedSplits,
    JBFundAccessConstraints[] calldata _fundAccessConstraints,
    string calldata _memo
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)
    returns (uint256 configuration)
  {
    // Configure the next funding cycle.
    configuration = _configure(
      _projectId,
      _data,
      _metadata,
      _mustStartAtOrAfter,
      _groupedSplits,
      _fundAccessConstraints
    );

    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);
  }

  /**
    @notice
    Issues an owner's ERC20 JBTokens that'll be used when claiming tokens.

    @dev
    Deploys a project's ERC20 JBToken contract.

    @dev
    Only a project's owner or operator can issue its token.

    @param _projectId The ID of the project being issued tokens.
    @param _name The ERC20's name.
    @param _symbol The ERC20's symbol.
  */
  function issueTokenFor(
    uint256 _projectId,
    string calldata _name,
    string calldata _symbol
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)
    returns (IJBToken token)
  {
    // Issue the token in the store.
    return tokenStore.issueFor(_projectId, _name, _symbol);
  }

  /**
    @notice
    Swap the current project's token that is minted and burned for another, and transfer ownership of the current token to another address if needed.

    @dev
    Only a project's owner or operator can change its token.

    @param _projectId The ID of the project to which the changed token belongs.
    @param _token The new token.
    @param _newOwner An address to transfer the current token's ownership to. This is optional, but it cannot be done later.
  */
  function changeTokenOf(
    uint256 _projectId,
    IJBToken _token,
    address _newOwner
  )
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)
  {
    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // The current funding cycle must not be paused.
    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();

    // Change the token in the store.
    tokenStore.changeFor(_projectId, _token, _newOwner);
  }

  /**
    @notice
    Mint new token supply into an account, and optionally reserve a supply to be distributed according to the project's current funding cycle configuration.

    @dev
    Only a project's owner, a designated operator, one of its terminals, or the current data source can mint its tokens.

    @param _projectId The ID of the project to which the tokens being minted belong.
    @param _tokenCount The amount of tokens to mint in total, counting however many should be reserved.
    @param _beneficiary The account that the tokens are being minted for.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be minted if they have been issued.
    @param _useReservedRate Whether to use the current funding cycle's reserved rate in the mint calculation.

    @return beneficiaryTokenCount The amount of tokens minted for the beneficiary.
  */
  function mintTokensOf(
    uint256 _projectId,
    uint256 _tokenCount,
    address _beneficiary,
    string calldata _memo,
    bool _preferClaimedTokens,
    bool _useReservedRate
  ) external virtual override returns (uint256 beneficiaryTokenCount) {
    // There should be tokens to mint.
    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();

    // Define variables that will be needed outside scoped section below.
    // Keep a reference to the reserved rate to use
    uint256 _reservedRate;

    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.
    {
      // Get a reference to the project's current funding cycle.
      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source
      _requirePermissionAllowingOverride(
        projects.ownerOf(_projectId),
        _projectId,
        JBOperations.MINT,
        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||
          msg.sender == address(_fundingCycle.dataSource())
      );

      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.
      if (
        !_fundingCycle.mintingAllowed() &&
        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&
        msg.sender != address(_fundingCycle.dataSource())
      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();

      // Determine the reserved rate to use.
      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;
    }

    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)
      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.
      _processedTokenTrackerOf[_projectId] =
        _processedTokenTrackerOf[_projectId] -
        int256(_tokenCount);
    else {
      // The unreserved token count that will be minted for the beneficiary.
      beneficiaryTokenCount = PRBMath.mulDiv(
        _tokenCount,
        JBConstants.MAX_RESERVED_RATE - _reservedRate,
        JBConstants.MAX_RESERVED_RATE
      );

      if (_reservedRate == 0)
        // If there's no reserved rate, increment the tracker with the newly minted tokens.
        _processedTokenTrackerOf[_projectId] =
          _processedTokenTrackerOf[_projectId] +
          int256(beneficiaryTokenCount);

      // Mint the tokens.
      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);
    }

    emit MintTokens(
      _beneficiary,
      _projectId,
      _tokenCount,
      beneficiaryTokenCount,
      _memo,
      _reservedRate,
      msg.sender
    );
  }

  /**
    @notice
    Burns a token holder's supply.

    @dev
    Only a token's holder, a designated operator, or a project's terminal can burn it.

    @param _holder The account that is having its tokens burned.
    @param _projectId The ID of the project to which the tokens being burned belong.
    @param _tokenCount The number of tokens to burn.
    @param _memo A memo to pass along to the emitted event.
    @param _preferClaimedTokens A flag indicating whether a project's attached token contract should be burned first if they have been issued.
  */
  function burnTokensOf(
    address _holder,
    uint256 _projectId,
    uint256 _tokenCount,
    string calldata _memo,
    bool _preferClaimedTokens
  )
    external
    virtual
    override
    requirePermissionAllowingOverride(
      _holder,
      _projectId,
      JBOperations.BURN,
      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    )
  {
    // There should be tokens to burn
    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // If the message sender is not a terminal, the current funding cycle must not be paused.
    if (
      _fundingCycle.burnPaused() &&
      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))
    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();

    // Update the token tracker so that reserved tokens will still be correctly mintable.
    _processedTokenTrackerOf[_projectId] =
      _processedTokenTrackerOf[_projectId] -
      int256(_tokenCount);

    // Burn the tokens.
    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);

    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);
  }

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return The amount of minted reserved tokens.
  */
  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)
    external
    virtual
    override
    returns (uint256)
  {
    return _distributeReservedTokensOf(_projectId, _memo);
  }

  /**
    @notice
    Allows other controllers to signal to this one that a migration is expected for the specified project.

    @dev
    This controller should not yet be the project's controller.

    @param _projectId The ID of the project that will be migrated to this controller.
    @param _from The controller being migrated from.
  */
  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {
    // This controller must not be the project's current controller.
    if (directory.controllerOf(_projectId) == address(this))
      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();

    // Set the tracker as the total supply.
    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));

    emit PrepMigration(_projectId, _from, msg.sender);
  }

  /**
    @notice
    Allows a project to migrate from this controller to another.

    @dev
    Only a project's owner or a designated operator can migrate it.

    @param _projectId The ID of the project that will be migrated from this controller.
    @param _to The controller to which the project is migrating.
  */
  function migrate(uint256 _projectId, IJBMigratable _to)
    external
    virtual
    override
    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)
  {
    // This controller must be the project's current controller.
    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();

    // Get a reference to the project's current funding cycle.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Migration must be allowed.
    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();

    // All reserved tokens must be minted before migrating.
    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))
      _distributeReservedTokensOf(_projectId, '');

    // Make sure the new controller is prepped for the migration.
    _to.prepForMigrationOf(_projectId, address(this));

    // Set the new controller.
    directory.setControllerOf(_projectId, address(_to));

    emit Migrate(_projectId, _to, msg.sender);
  }

  //*********************************************************************//
  // ------------------------ internal functions ----------------------- //
  //*********************************************************************//

  /**
    @notice
    Distributes all outstanding reserved tokens for a project.

    @param _projectId The ID of the project to which the reserved tokens belong.
    @param _memo A memo to pass along to the emitted event.

    @return tokenCount The amount of minted reserved tokens.
  */
  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)
    internal
    returns (uint256 tokenCount)
  {
    // Get the current funding cycle to read the reserved rate from.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);

    // Get a reference to new total supply of tokens before minting reserved tokens.
    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);

    // Get a reference to the number of tokens that need to be minted.
    tokenCount = _reservedTokenAmountFrom(
      _processedTokenTrackerOf[_projectId],
      _fundingCycle.reservedRate(),
      _totalTokens
    );

    // Set the tracker to be the new total supply.
    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);

    // Get a reference to the project owner.
    address _owner = projects.ownerOf(_projectId);

    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.
    uint256 _leftoverTokenCount = tokenCount == 0
      ? 0
      : _distributeToReservedTokenSplitsOf(
        _projectId,
        _fundingCycle.configuration,
        JBSplitsGroups.RESERVED_TOKENS,
        tokenCount
      );

    // Mint any leftover tokens to the project owner.
    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);

    emit DistributeReservedTokens(
      _fundingCycle.configuration,
      _fundingCycle.number,
      _projectId,
      _owner,
      tokenCount,
      _leftoverTokenCount,
      _memo,
      msg.sender
    );
  }

  /**
    @notice
    Distribute tokens to the splits according to the specified funding cycle configuration.

    @param _projectId The ID of the project for which reserved token splits are being distributed.
    @param _domain The domain of the splits to distribute the reserved tokens between.
    @param _group The group of the splits to distribute the reserved tokens between.
    @param _amount The total amount of tokens to mint.

    @return leftoverAmount If the splits percents dont add up to 100%, the leftover amount is returned.
  */
  function _distributeToReservedTokenSplitsOf(
    uint256 _projectId,
    uint256 _domain,
    uint256 _group,
    uint256 _amount
  ) internal returns (uint256 leftoverAmount) {
    // Set the leftover amount to the initial amount.
    leftoverAmount = _amount;

    // Get a reference to the project's reserved token splits.
    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);

    //Transfer between all splits.
    for (uint256 _i = 0; _i < _splits.length; _i++) {
      // Get a reference to the split being iterated on.
      JBSplit memory _split = _splits[_i];

      // The amount to send towards the split.
      uint256 _tokenCount = PRBMath.mulDiv(
        _amount,
        _split.percent,
        JBConstants.SPLITS_TOTAL_PERCENT
      );

      // Mints tokens for the split if needed.
      if (_tokenCount > 0) {
        tokenStore.mintFor(
          // If an allocator is set in the splits, set it as the beneficiary.
          // Otherwise if a projectId is set in the split, set the project's owner as the beneficiary.
          // If the split has a beneficiary send to the split's beneficiary. Otherwise send to the msg.sender.
          _split.allocator != IJBSplitAllocator(address(0))
            ? address(_split.allocator)
            : _split.projectId != 0
            ? projects.ownerOf(_split.projectId)
            : _split.beneficiary != address(0)
            ? _split.beneficiary
            : msg.sender,
          _projectId,
          _tokenCount,
          _split.preferClaimed
        );

        // If there's an allocator set, trigger its `allocate` function.
        if (_split.allocator != IJBSplitAllocator(address(0)))
          _split.allocator.allocate(
            JBSplitAllocationData(
              address(tokenStore.tokenOf(_projectId)),
              _tokenCount,
              18,
              _projectId,
              _group,
              _split
            )
          );

        // Subtract from the amount to be sent to the beneficiary.
        leftoverAmount = leftoverAmount - _tokenCount;
      }

      emit DistributeToReservedTokenSplit(
        _projectId,
        _domain,
        _group,
        _split,
        _tokenCount,
        msg.sender
      );
    }
  }

  /**
    @notice
    Configures a funding cycle and stores information pertinent to the configuration.

    @param _projectId The ID of the project whose funding cycles are being reconfigured.
    @param _data Data that defines the funding cycle. These properties will remain fixed for the duration of the funding cycle.
    @param _metadata Metadata specifying the controller specific params that a funding cycle can have. These properties will remain fixed for the duration of the funding cycle.
    @param _mustStartAtOrAfter The time before which the configured funding cycle cannot start.
    @param _groupedSplits An array of splits to set for any number of groups. 
    @param _fundAccessConstraints An array containing amounts that a project can use from its treasury for each payment terminal. Amounts are fixed point numbers using the same number of decimals as the accompanying terminal.

    @return configuration The configuration of the funding cycle that was successfully reconfigured.
  */
  function _configure(
    uint256 _projectId,
    JBFundingCycleData calldata _data,
    JBFundingCycleMetadata calldata _metadata,
    uint256 _mustStartAtOrAfter,
    JBGroupedSplits[] memory _groupedSplits,
    JBFundAccessConstraints[] memory _fundAccessConstraints
  ) internal returns (uint256) {
    // Make sure the provided reserved rate is valid.
    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();

    // Make sure the provided redemption rate is valid.
    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_REDEMPTION_RATE();

    // Make sure the provided ballot redemption rate is valid.
    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)
      revert INVALID_BALLOT_REDEMPTION_RATE();

    // Configure the funding cycle's properties.
    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(
      _projectId,
      _data,
      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),
      _mustStartAtOrAfter
    );

    // Set splits for the group.
    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);

    // Set distribution limits if there are any.
    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {
      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];

      // If distribution limit value is larger than 232 bits, revert.
      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();

      // If distribution limit currency value is larger than 24 bits, revert.
      if (_constraints.distributionLimitCurrency > type(uint24).max)
        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();

      // If overflow allowance value is larger than 232 bits, revert.
      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();

      // If overflow allowance currency value is larger than 24 bits, revert.
      if (_constraints.overflowAllowanceCurrency > type(uint24).max)
        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();

      // Set the distribution limit if there is one.
      if (_constraints.distributionLimit > 0)
        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.distributionLimit |
          (_constraints.distributionLimitCurrency << 232);

      // Set the overflow allowance if there is one.
      if (_constraints.overflowAllowance > 0)
        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][
          _constraints.terminal
        ][_constraints.token] =
          _constraints.overflowAllowance |
          (_constraints.overflowAllowanceCurrency << 232);

      emit SetFundAccessConstraints(
        _fundingCycle.configuration,
        _fundingCycle.number,
        _projectId,
        _constraints,
        msg.sender
      );
    }

    return _fundingCycle.configuration;
  }

  /**
    @notice
    Gets the amount of reserved tokens currently tracked for a project given a reserved rate.

    @param _processedTokenTracker The tracker to make the calculation with.
    @param _reservedRate The reserved rate to use to make the calculation.
    @param _totalEligibleTokens The total amount to make the calculation with.

    @return amount reserved token amount.
  */
  function _reservedTokenAmountFrom(
    int256 _processedTokenTracker,
    uint256 _reservedRate,
    uint256 _totalEligibleTokens
  ) internal pure returns (uint256) {
    // Get a reference to the amount of tokens that are unprocessed.
    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0
      ? _totalEligibleTokens - uint256(_processedTokenTracker)
      : _totalEligibleTokens + uint256(-_processedTokenTracker);

    // If there are no unprocessed tokens, return.
    if (_unprocessedTokenBalanceOf == 0) return 0;

    // If all tokens are reserved, return the full unprocessed amount.
    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;

    return
      PRBMath.mulDiv(
        _unprocessedTokenBalanceOf,
        JBConstants.MAX_RESERVED_RATE,
        JBConstants.MAX_RESERVED_RATE - _reservedRate
      ) - _unprocessedTokenBalanceOf;
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

